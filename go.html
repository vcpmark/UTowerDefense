<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UTower Defense - v5.0 (Auto-Play Analyzer)</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #0f1220; color: #e8eaf6; }
    .wrap { display: grid; grid-template-columns: 820px 1fr; gap: 16px; padding: 16px; align-items: start; }
    .panel { background: #141830; border: 1px solid #263059; border-radius: 16px; padding: 12px 14px; box-shadow: 0 4px 24px rgba(0,0,0,.25); display: flex; flex-direction: column; gap: 12px; }
    canvas { background: #0b0f1f; border-radius: 12px; border: 1px solid #273057; display:block; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .row.tight { gap: 6px; }
    .btn { background: #2a3470; color: #fff; border: 0; padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 600; letter-spacing: .2px; transition: background .2s ease; }
    .btn:hover { background: #374298; }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    .btn.ghost { background: rgba(42,52,112,0.12); border: 1px solid #2c3770; color: #b7c2ff; }
    .btn.ghost:hover { background: rgba(90,108,196,0.16); }
    .badge { background: #1a2047; padding: 6px 10px; border-radius: 999px; border: 1px solid #2c3770; font-size: 12px; text-transform: uppercase; letter-spacing: .08em; }
    .pill { background:#1a2047; border:1px solid #2c3770; border-radius:999px; padding:6px 12px; font-size: 13px; }
    .pill.warn { background: rgba(148,54,73,0.18); border-color: rgba(248,113,113,0.6); color: #fda4af; }
    .pill.success { background: rgba(34,197,94,0.18); border-color: rgba(74,222,128,0.55); color: #bbf7d0; }
    .shop-card { display: grid; grid-template-columns: 1fr auto; gap: 6px; padding: 10px; border: 1px dashed #2a3470; border-radius: 10px; background: rgba(15,20,43,0.45); }
    .shop-list { display: flex; flex-direction: column; gap: 10px; }
    .tower-card { cursor: pointer; }
    .tower-card.selected { border: 1px solid #7081ff; background: rgba(91,114,255,0.18); box-shadow: 0 0 0 1px rgba(112,129,255,0.25); }
    .tower-card strong { font-size: 16px; }
    .tower-header { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .tower-meta { display:flex; gap:10px; flex-wrap:wrap; font-size:13px; color:#a6b3f5; margin:4px 0; }
    select, input[type="text"], input[type="number"] { background: #1a2047; color: #e8eaf6; border: 1px solid #2c3770; border-radius: 10px; padding: 8px 10px; }
    pre.log { white-space:pre-wrap; max-height:520px; min-height:200px; overflow:auto; resize: vertical; background:#0b0f1f; padding:8px; border-radius:8px; border:1px solid #273057; font-size:13px; }
    pre.log.small { min-height:120px; }
    #autoReport { min-height:140px; }
    .debug-panel { display:none; flex-direction: column; gap: 12px; }
    .debug-panel.active { display:flex; }
    label.input-label { display:flex; align-items:center; gap:6px; font-size:13px; color:#b2bbf8; }
    .section-title { font-weight:600; text-transform:uppercase; font-size:12px; letter-spacing:0.12em; color:#94a3ff; margin-bottom:4px; }
    .event-card { border-style: solid; border-color: rgba(112,129,255,0.25); background: rgba(23,30,68,0.55); }
    .event-card .badge { background: rgba(112,129,255,0.18); border-color: rgba(112,129,255,0.45); }
    .meter { position: relative; width: 100%; height: 12px; border-radius: 999px; background: rgba(30,41,82,0.65); overflow: hidden; border: 1px solid rgba(112,129,255,0.25); }
    .meter-fill { position:absolute; inset:0; width: 0%; border-radius: 999px; background: linear-gradient(90deg, #38bdf8, #c084fc); box-shadow: 0 0 12px rgba(56,189,248,0.45); transition: width .25s ease; }
    .event-highlight { color:#facc15; font-weight:600; }
    #crowdCard.success { border-color: rgba(74,222,128,0.45); background: rgba(34,197,94,0.12); }
    #crowdCard.failed { border-color: rgba(248,113,113,0.45); background: rgba(148,54,73,0.12); }
    #crowdCard .meter { margin-top: 4px; }
    #crowdCard .meter-fill { transition: width .18s ease; }
    #momentumCard .meter { margin-top: 6px; }
    #momentumCard .meter-fill { background: linear-gradient(90deg, #f472b6, #fb7185); box-shadow: 0 0 12px rgba(244,114,182,0.45); }
    @media (max-width: 1320px) {
      .wrap { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <canvas id="game" width="800" height="480"></canvas>
    </div>

    <div class="panel">
      <div class="row" style="justify-content: space-between;">
        <div style="font-weight:800; font-size:20px;">UTower Defense</div>
        <div class="badge">v5.0 ‚Ä¢ Auto-Play Analyzer</div>
      </div>

      <div class="row" style="gap: 12px;">
        <div>üí∞ Money: <span id="money">0</span></div>
        <div>‚ù§Ô∏è Lives: <span id="lives">0</span></div>
        <div>üåä Wave: <span id="wave">0</span></div>
        <div>üëæ Enemies: <span id="enemies">0</span></div>
      </div>

      <div class="row" style="gap:12px; align-items: center;">
        <label>Difficulty
          <select id="difficulty">
            <option value="Easy">Easy</option>
            <option value="Normal" selected>Normal</option>
            <option value="Hard">Hard</option>
          </select>
        </label>
        <button id="speedBtn" class="btn">Speed: 1x</button>
        <span class="pill" id="modeIndicator">Normal ‚Ä¢ 1x</span>
      </div>

      <div class="row" style="gap:12px; align-items:center;">
        <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;">
          <input id="autoStart" type="checkbox" /> Auto‚Äëstart next wave
        </label>
        <button id="autoPlayBtn" class="btn">Auto‚ÄëPlay: Off</button>
        <button id="soundBtn" class="btn">Sound: On</button>
      </div>

      <div class="row" style="gap:12px; align-items:center;">
        <button id="startWave" class="btn">Start Wave</button>
        <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;">
          <input id="buildMode" type="checkbox" /> Build mode
        </label>
        <button id="sellMode" class="btn">Sell Mode</button>
        <span id="towerInfo" class="pill">Select a tower to build</span>
      </div>

      <div class="shop-card event-card" id="eventCard">
        <div>
          <div class="tower-header"><strong>Wave Modifier</strong><span id="eventName" class="badge">None</span></div>
          <div id="eventDesc" style="color:#9aa3d7; font-size:13px;">Each wave now rolls a playful twist. Clear waves to reveal the next surprise.</div>
        </div>
        <div></div>
      </div>

      <div class="shop-card" id="hypeCard">
        <div>
          <div class="tower-header"><strong>Hype Burst</strong><button id="hypeBtn" class="btn ghost" disabled>Charge: 0%</button></div>
          <div style="color:#9aa3d7; font-size:13px;">Defeating enemies fills the hype meter. Unleash it to supercharge your defenses. <span id="hypeStatus" class="pill">Dormant</span></div>
          <div class="meter" style="margin-top:6px;"><div id="hypeMeter" class="meter-fill"></div></div>
        </div>
        <div></div>
      </div>

      <div class="shop-card event-card" id="momentumCard">
        <div>
          <div class="tower-header"><strong id="momentumName">Momentum Chain</strong><span id="momentumBadge" class="badge">Building</span></div>
          <div id="momentumDesc" style="color:#9aa3d7; font-size:13px;">Chain swift eliminations to ignite a Frenzy that drenches towers in speed and power.</div>
          <div class="meter"><div id="momentumMeter" class="meter-fill"></div></div>
          <div class="row tight" style="justify-content: space-between; align-items:center;">
            <span id="momentumStatus" class="pill">Build momentum</span>
            <span id="momentumProgressLabel" style="font-size:12px;color:#9aa3d7;">0%</span>
            <span id="momentumCombo" class="badge">Chain x0</span>
          </div>
        </div>
        <div></div>
      </div>

      <div class="shop-card event-card" id="crowdCard">
        <div>
          <div class="tower-header"><strong id="crowdName">Crowd Request</strong><span id="crowdReward" class="badge">Awaiting</span></div>
          <div id="crowdDesc" style="color:#9aa3d7; font-size:13px;">Clear waves to unlock special requests from the roaring arena crowd.</div>
          <div class="meter"><div id="crowdMeter" class="meter-fill"></div></div>
          <div class="row tight" style="justify-content: space-between; align-items:center;">
            <span id="crowdStatus" class="pill">Awaiting wave</span>
            <span id="crowdProgressLabel" style="font-size:12px;color:#9aa3d7;">0%</span>
            <span id="crowdStreak" class="badge">Streak 0</span>
          </div>
        </div>
        <div></div>
      </div>

      <div>
        <div class="section-title">Towers</div>
        <div id="towerShop" class="shop-list"></div>
      </div>

      <div class="shop-card">
        <div>
          <div class="tower-header"><strong>Auto-Play Analyzer</strong><span id="autoReportStatus" class="pill">Idle</span></div>
          <div style="color:#9aa3d7; font-size:13px; margin-bottom:6px;">Let the AI run waves and capture balance feedback instantly.</div>
          <pre id="autoReport" class="log small">Toggle auto-play to let the AI experiment and gather tuning data.</pre>
        </div>
        <div></div>
      </div>

      <div class="row" style="justify-content:flex-end;">
        <button id="debugToggle" class="btn ghost">Show Debug Tools</button>
      </div>

      <div id="debugPanel" class="debug-panel">
        <div class="shop-card" id="tunerCard">
          <div>
            <div class="tower-header"><strong>Balance Auto-Tune</strong><span class="pill">Debug</span></div>
            <div style="color:#9aa3d7; font-size:13px; margin:6px 0;">Runs background simulations with auto-play to adjust balance targets.</div>
            <div class="row tight" style="margin-bottom:6px;">
              <label class="input-label">Target <input id="targetWave" type="number" value="100" style="width:72px"></label>
              <label class="input-label">Max <input id="simMax" type="number" value="160" style="width:72px"></label>
              <label class="input-label">Iters <input id="simIters" type="number" value="12" style="width:56px"></label>
              <button id="runAutoTune" class="btn">Run</button>
              <button id="copyLog" class="btn ghost">Copy Log</button>
            </div>
            <pre id="simOut" class="log small"></pre>
          </div>
        </div>

        <div class="shop-card">
          <div>
            <div class="tower-header"><strong>Current Balance Params</strong><button id="resetBal" class="btn ghost">Reset BAL</button></div>
            <pre id="paramDump" class="log small"></pre>
          </div>
          <div></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const UI = {
      money: document.getElementById('money'),
      lives: document.getElementById('lives'),
      wave: document.getElementById('wave'),
      enemies: document.getElementById('enemies'),
      startWave: document.getElementById('startWave'),
      buildMode: document.getElementById('buildMode'),
      sellMode: document.getElementById('sellMode'),
      difficulty: document.getElementById('difficulty'),
      speedBtn: document.getElementById('speedBtn'),
      modeIndicator: document.getElementById('modeIndicator'),
      autoStart: document.getElementById('autoStart'),
      autoPlayBtn: document.getElementById('autoPlayBtn'),
      soundBtn: document.getElementById('soundBtn'),
      towerShop: document.getElementById('towerShop'),
      towerInfo: document.getElementById('towerInfo'),
      autoReport: document.getElementById('autoReport'),
      autoReportStatus: document.getElementById('autoReportStatus'),
      debugToggle: document.getElementById('debugToggle'),
      debugPanel: document.getElementById('debugPanel'),
      simOut: document.getElementById('simOut'),
      runAutoTune: document.getElementById('runAutoTune'),
      targetWave: document.getElementById('targetWave'),
      simMax: document.getElementById('simMax'),
      simIters: document.getElementById('simIters'),
      paramDump: document.getElementById('paramDump'),
      resetBal: document.getElementById('resetBal'),
      copyLog: document.getElementById('copyLog'),
      eventName: document.getElementById('eventName'),
      eventDesc: document.getElementById('eventDesc'),
      hypeBtn: document.getElementById('hypeBtn'),
      hypeMeter: document.getElementById('hypeMeter'),
      hypeStatus: document.getElementById('hypeStatus'),
      momentumCard: document.getElementById('momentumCard'),
      momentumMeter: document.getElementById('momentumMeter'),
      momentumStatus: document.getElementById('momentumStatus'),
      momentumProgressLabel: document.getElementById('momentumProgressLabel'),
      momentumCombo: document.getElementById('momentumCombo'),
      momentumBadge: document.getElementById('momentumBadge'),
      crowdCard: document.getElementById('crowdCard'),
      crowdName: document.getElementById('crowdName'),
      crowdDesc: document.getElementById('crowdDesc'),
      crowdReward: document.getElementById('crowdReward'),
      crowdMeter: document.getElementById('crowdMeter'),
      crowdStatus: document.getElementById('crowdStatus'),
      crowdProgressLabel: document.getElementById('crowdProgressLabel'),
      crowdStreak: document.getElementById('crowdStreak')
    };

    const GRID = 40; const W = canvas.width; const H = canvas.height;

    const TOWER_TYPES = {
      basic: {
        name: 'Orbit Cannon',
        icon: 'üõ∞Ô∏è',
        color: '#5b72ff',
        cost: 60,
        range: 140,
        rate: 0.48,
        damage: 18,
        pierce: 0,
        description: 'Reliable single-target coverage for early waves.',
        bullet: { speed: 360, r: 3.5, color: '#cdd9ff' },
        upgrade(tower){
          tower.damage = Math.round(tower.damage * 1.22);
          tower.rate = Math.max(0.18, +(tower.rate * 0.92).toFixed(2));
          tower.range = Math.min(220, tower.range + 12);
          if(tower.level % 3 === 0) tower.pierce++;
        }
      },
      pulse: {
        name: 'Pulse Emitter',
        icon: 'üí•',
        color: '#f472b6',
        cost: 105,
        range: 135,
        rate: 0.85,
        damage: 24,
        pierce: 0,
        description: 'Explosive bursts damage clustered creeps.',
        bullet: { speed: 300, r: 4, color: '#f9a8d4', splashRadius: 60, splashFalloff: 0.6 },
        upgrade(tower){
          tower.damage = Math.round(tower.damage * 1.26);
          tower.range = Math.min(190, tower.range + 10);
          tower.rate = Math.max(0.55, +(tower.rate * 0.93).toFixed(2));
          tower.bullet.splashRadius = (tower.bullet.splashRadius || 60) + 6;
        }
      },
      frost: {
        name: 'Cryo Tower',
        icon: '‚ùÑÔ∏è',
        color: '#38bdf8',
        cost: 85,
        range: 150,
        rate: 0.52,
        damage: 12,
        pierce: 0,
        description: 'Chills enemies, slowing their advance.',
        bullet: { speed: 320, r: 3.4, color: '#bae6fd', slow: { factor: 0.55, duration: 1.8 } },
        upgrade(tower){
          tower.damage = Math.round(tower.damage * 1.18);
          tower.range = Math.min(210, tower.range + 12);
          tower.rate = Math.max(0.34, +(tower.rate * 0.94).toFixed(2));
          const slow = tower.bullet.slow || { factor: 0.55, duration: 1.6 };
          slow.duration += 0.2;
          slow.factor = Math.max(0.38, slow.factor - 0.02);
          tower.bullet.slow = slow;
        }
      },
      sniper: {
        name: 'Railgun Tower',
        icon: 'üéØ',
        color: '#f97316',
        cost: 125,
        range: 240,
        rate: 1.35,
        damage: 120,
        pierce: 2,
        description: 'Massive piercing shots punish tough bosses.',
        bullet: { speed: 520, r: 4.5, color: '#facc15' },
        upgrade(tower){
          tower.damage = Math.round(tower.damage * 1.34);
          tower.range = Math.min(320, tower.range + 14);
          tower.rate = Math.max(0.9, +(tower.rate * 0.95).toFixed(2));
          if(tower.level % 2 === 0) tower.pierce++;
        }
      },
      storm: {
        name: 'Storm Nexus',
        icon: '‚ö°',
        color: '#fde68a',
        cost: 150,
        range: 160,
        rate: 1.05,
        damage: 52,
        pierce: 0,
        chainTargets: 3,
        chainRange: 150,
        chainFalloff: 0.75,
        description: 'Arcs chain lightning between clustered enemies.',
        fire(tower, target, mods){ performChainLightning(tower, target, mods); },
        upgrade(tower){
          tower.damage = Math.round(tower.damage * 1.24);
          tower.range = Math.min(230, tower.range + 14);
          tower.rate = Math.max(0.65, +(tower.rate * 0.92).toFixed(2));
          tower.chainTargets = Math.min(6, (tower.chainTargets || 3) + (tower.level % 2 === 0 ? 1 : 0));
          tower.chainRange = Math.min(220, (tower.chainRange || 150) + 10);
        }
      },
      resonance: {
        name: 'Resonance Beacon',
        icon: 'üåÄ',
        color: '#c084fc',
        cost: 110,
        range: 0,
        rate: 1.2,
        damage: 0,
        pierce: 0,
        utility: true,
        aura: { range: 160, damageMult: 1.12, rateMult: 0.88, rangeBonus: 8 },
        description: 'Projects an empowering aura that speeds nearby towers.',
        utilityUpdate(tower, dt){
          tower.pulseTimer = (tower.pulseTimer || 0) + dt * state.speedMultiplier;
          if(tower.pulseTimer >= 1.4){
            tower.pulseTimer = 0;
            state.pulses.push({ x: tower.x, y: tower.y, r: 0, max: (tower.aura?.range || 150), ttl: 0.7, life: 0.7, color:'#c084fc' });
          }
        },
        postDraw(tower, ctx){
          const radius = tower.aura?.range || 0;
          if(radius <= 0) return;
          ctx.save();
          ctx.globalAlpha = 0.18;
          ctx.strokeStyle = '#c084fc';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(tower.x, tower.y, radius, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        },
        upgrade(tower){
          if(!tower.aura) tower.aura = { range:160, damageMult:1.12, rateMult:0.88, rangeBonus:8 };
          tower.aura.range = Math.min(240, tower.aura.range + 12);
          tower.aura.damageMult = +(tower.aura.damageMult + 0.04).toFixed(2);
          tower.aura.rateMult = +Math.max(0.6, tower.aura.rateMult - 0.05).toFixed(2);
          tower.aura.rangeBonus = Math.min(42, (tower.aura.rangeBonus || 0) + 3);
        }
      }
    };

    const state = {
      money: 120,
      lives: 20,
      wave: 0,
      enemiesRemaining: 0,
      build: false,
      selling: false,
      selectedTowerType: 'basic',
      selectedTowerCost: TOWER_TYPES.basic.cost,
      towers: [],
      bullets: [],
      enemies: [],
      lastTime: 0,
      blocked: new Set(),
      gameOver: false,
      waveClearedBonusGiven: false,
      difficulty: 'Normal',
      speedMultiplier: 1,
      autoStart: false,
      autoPlay: false,
      aiPlaceCooldown: 0,
      aiUpgradeCooldown: 0,
      selected: null,
      wavePlan: [],
      waveClock: 0,
      kills: 0,
      totalEarned: 0,
      towersBuilt: 0,
      autoReport: null,
      silenceAutoReport: false,
      debugVisible: false,
      eventModifiers: null,
      activeEvent: null,
      lightning: [],
      pulses: [],
      hype: 0,
      hypeMax: 120,
      hypeActiveTimer: 0,
      hypeDuration: 8,
      hypeReadyPinged: false,
      momentum: 0,
      momentumMax: 100,
      momentumActiveTimer: 0,
      momentumDuration: 5.5,
      momentumChainGrace: 0,
      momentumDecayRate: 12,
      momentumCombo: 0,
      momentumLastKillTime: 0,
      crowdRequest: null,
      crowdTracker: null,
      crowdStreak: 0
    };

    const BAL = {
      hpLinearSlope: 0.020846,
      hpPeriodicEvery: 10,
      hpPeriodicStep: 0.140854,
      countSlope: 0.061848,
      bossEvery: 8,
      bossLeakLives: 3,
      rewardSlope: 0.013,
      clearBase: 8,
      clearPer: 3,
      armorPerWave: 0.8,
      armorTank: 10,
      armorBoss: 20,
      desiredTowersCap: 40,
      aiBaseDesired: 5,
      aiCooldown: 0.31
    };

    function dumpParams(){ if(UI.paramDump) UI.paramDump.textContent = JSON.stringify(BAL, null, 2); }

    const BASE_EVENT_MODIFIERS = Object.freeze({
      enemyHpMult: 1,
      enemySpeedMult: 1,
      enemyRewardMult: 1,
      towerDamageMult: 1,
      towerRateMult: 1,
      towerRangeBonus: 0,
      killBonus: 0,
      hypeGainBonus: 0,
      postWaveLife: 0
    });

    function resetEventModifiers(){ state.eventModifiers = { ...BASE_EVENT_MODIFIERS }; }

    const WAVE_EVENTS = [
      {
        key: 'treasure',
        name: 'Treasure Rush',
        description: 'Enemies sprint but drop bonus shards of cash.',
        apply(mods){ mods.killBonus += 4; mods.enemySpeedMult *= 1.12; mods.enemyRewardMult *= 1.05; }
      },
      {
        key: 'overcharge',
        name: 'Overcharge Grid',
        description: 'Towers fire faster and hit harder while the grid hums.',
        apply(mods){ mods.towerRateMult *= 0.85; mods.towerDamageMult *= 1.12; mods.hypeGainBonus += 2; }
      },
      {
        key: 'frostfront',
        name: 'Frostfront',
        description: 'A chill slows creeps, but crystalline armor bolsters them.',
        apply(mods){ mods.enemySpeedMult *= 0.82; mods.enemyHpMult *= 1.18; mods.enemyRewardMult *= 1.12; }
      },
      {
        key: 'meteor',
        name: 'Meteor Shower',
        description: 'Falling stardust peppers random enemies for chip damage.',
        apply(mods, eventState){ eventState.meteorTimer = 1.6; eventState.meteorDamage = 22; mods.hypeGainBonus += 1; },
        tick(eventState, dt){
          eventState.meteorTimer -= dt * state.speedMultiplier;
          if(eventState.meteorTimer <= 0){
            eventState.meteorTimer += 1.6;
            const alive = state.enemies.filter(e=>e && e.alive);
            if(alive.length){
              const target = alive[Math.floor(Math.random()*alive.length)];
              if(target){
                addLightningArc([{x:target.pos.x, y:0}, {x:target.pos.x + (Math.random()*20-10), y:target.pos.y}], '#facc15');
                applyDamage(target, eventState.meteorDamage, {owner:null});
              }
            }
          }
        }
      },
      {
        key: 'resonance',
        name: 'Resonant Grounds',
        description: 'The arena amplifies tower range and restores morale after waves.',
        apply(mods){ mods.towerRangeBonus += 12; mods.postWaveLife += 1; }
      }
    ];

    function hashWaveIndex(wave){
      const s = Math.sin(wave * 12.9898) * 43758.5453;
      return Math.abs(Math.floor(s));
    }

    function pickWaveEvent(wave){
      const idx = hashWaveIndex(wave) % WAVE_EVENTS.length;
      return WAVE_EVENTS[idx];
    }

    function applyWaveEvent(){
      resetEventModifiers();
      if(state.wave <= 0){ state.activeEvent = null; updateEventUI(); return; }
      const eventDef = pickWaveEvent(state.wave);
      const eventState = { key: eventDef.key, name: eventDef.name, description: eventDef.description, def: eventDef };
      if(typeof eventDef.apply === 'function') eventDef.apply(state.eventModifiers, eventState);
      state.activeEvent = eventState;
      updateEventUI();
    }

    function clearWaveEvent(){
      if(state.activeEvent && state.activeEvent.def && typeof state.activeEvent.def.onWaveCleared === 'function'){
        state.activeEvent.def.onWaveCleared(state.activeEvent);
      }
      const heal = state.eventModifiers && state.eventModifiers.postWaveLife ? state.eventModifiers.postWaveLife : 0;
      if(heal) state.lives = Math.min(40, state.lives + heal);
      state.activeEvent = null;
      resetEventModifiers();
      updateEventUI();
    }

    function updateSelectedTowerInfo(){
      const def = TOWER_TYPES[state.selectedTowerType] || TOWER_TYPES.basic;
      const infoParts = [`${def.icon} ${def.name}`, `$${def.cost}`];
      if(state.build) infoParts.push('Build mode');
      if(def.utility) infoParts.push('Aura tower');
      if(def.aura){
        if(def.aura.range) infoParts.push(`Aura range ${def.aura.range}`);
        if(def.aura.damageMult && def.aura.damageMult !== 1){
          const dmg = Math.round((def.aura.damageMult - 1) * 100);
          infoParts.push(`Damage +${dmg}%`);
        }
        if(def.aura.rateMult && def.aura.rateMult !== 1){
          const speed = def.aura.rateMult < 1 ? Math.round((1 - def.aura.rateMult) * 100) : -Math.round((def.aura.rateMult - 1) * 100);
          infoParts.push(`${speed >= 0 ? 'Speed +' : 'Speed '}${speed}%`);
        }
      }
      const missing = def.cost - state.money;
      if(missing > 0) infoParts.push(`Need $${missing}`);
      UI.towerInfo.textContent = infoParts.join(' ‚Ä¢ ');
      UI.towerInfo.classList.toggle('warn', missing > 0);
    }

    function updateEventUI(){
      if(!UI.eventName || !UI.eventDesc) return;
      if(state.activeEvent){
        UI.eventName.textContent = state.activeEvent.name;
        UI.eventDesc.textContent = state.activeEvent.description;
      } else if(state.wave === 0){
        UI.eventName.textContent = 'None';
        UI.eventDesc.textContent = 'Each wave now rolls a playful twist. Clear waves to reveal the next surprise.';
      } else {
        UI.eventName.textContent = 'Pending';
        UI.eventDesc.textContent = 'Wave cleared! Ready up to discover the next modifier.';
      }
    }

    function updateHypeUI(){
      if(!UI.hypeBtn || !UI.hypeMeter || !UI.hypeStatus) return;
      const pct = Math.min(1, state.hype / state.hypeMax);
      UI.hypeMeter.style.width = `${Math.round(pct * 100)}%`;
      UI.hypeBtn.textContent = `Charge: ${Math.round(pct * 100)}%`;
      const ready = pct >= 1 && state.hypeActiveTimer <= 0;
      UI.hypeBtn.disabled = !ready;
      UI.hypeBtn.classList.toggle('ghost', !ready);
      if(state.hypeActiveTimer > 0){
        UI.hypeStatus.textContent = 'Surging';
        UI.hypeStatus.classList.remove('warn');
      } else if(ready){
        UI.hypeStatus.textContent = 'Ready!';
        UI.hypeStatus.classList.add('warn');
      } else {
        UI.hypeStatus.textContent = 'Dormant';
        UI.hypeStatus.classList.remove('warn');
      }
    }

    function gainHype(amount){
      if(!amount) return;
      state.hype = Math.min(state.hypeMax, state.hype + amount);
      if(state.hype >= state.hypeMax && !state.hypeReadyPinged){
        state.hypeReadyPinged = true;
      }
      updateHypeUI();
    }

    function updateMomentumUI(){
      if(!UI.momentumMeter || !UI.momentumStatus) return;
      const pct = state.momentumMax > 0 ? Math.min(1, state.momentum / state.momentumMax) : 0;
      const pctText = `${Math.round(pct * 100)}%`;
      UI.momentumMeter.style.width = pctText;
      if(UI.momentumProgressLabel) UI.momentumProgressLabel.textContent = pctText;
      if(UI.momentumCombo) UI.momentumCombo.textContent = `Chain x${state.momentumCombo || 0}`;
      const active = state.momentumActiveTimer > 0;
      const ready = !active && pct >= 1;
      if(UI.momentumBadge){
        UI.momentumBadge.textContent = active ? 'Frenzy' : ready ? 'Ready' : 'Building';
      }
      if(UI.momentumStatus){
        UI.momentumStatus.textContent = active
          ? `Frenzy ${Math.min(10, Math.max(1, state.momentumCombo || 1))}x boost`
          : ready
          ? 'Tap into the roar!'
          : (state.momentumChainGrace || 0) > 0
            ? 'Chain holding'
            : 'Build momentum';
        UI.momentumStatus.classList.remove('warn', 'success');
        if(active) UI.momentumStatus.classList.add('success');
        else if(ready) UI.momentumStatus.classList.add('warn');
      }
      if(UI.momentumCard){
        UI.momentumCard.classList.toggle('success', active);
      }
    }

    function shatterMomentum(leaks = 1){
      const severity = Math.max(1, leaks);
      const before = { timer: state.momentumActiveTimer, momentum: state.momentum, combo: state.momentumCombo };
      state.momentumActiveTimer = Math.max(0, state.momentumActiveTimer - severity * 1.5);
      state.momentum = Math.max(0, state.momentum - severity * 35);
      state.momentumCombo = Math.max(0, state.momentumCombo - severity * 2);
      state.momentumChainGrace = 0;
      if(
        before.timer !== state.momentumActiveTimer ||
        before.momentum !== state.momentum ||
        before.combo !== state.momentumCombo
      ){
        updateMomentumUI();
      }
    }

    function activateMomentum(auto = false){
      if(state.momentumActiveTimer > 0) return false;
      state.momentumActiveTimer = state.momentumDuration;
      state.momentum = 0;
      state.momentumChainGrace = 2.6;
      state.momentumCombo = Math.max(1, state.momentumCombo || 1);
      updateMomentumUI();
      if(!auto) AudioSys.ensure();
      state.pulses.push({ x: W/2, y: H/2, r: 0, max: Math.max(W, H), ttl: 0.55, life: 0.55, color: '#fb7185' });
      gainHype(6 + Math.min(10, state.momentumCombo) * 1.5);
      return true;
    }

    function gainMomentum(amount){
      if(!amount) return;
      if(state.momentumActiveTimer > 0){
        const before = state.momentumActiveTimer;
        state.momentumActiveTimer = Math.min(state.momentumDuration + 2.5, state.momentumActiveTimer + amount * 0.02);
        if(state.momentumActiveTimer !== before) updateMomentumUI();
        return;
      }
      const before = state.momentum;
      state.momentum = Math.min(state.momentumMax, state.momentum + amount);
      if(state.momentum >= state.momentumMax){
        activateMomentum(true);
      } else if(state.momentum !== before){
        updateMomentumUI();
      }
    }

    function handleMomentumKill(enemy){
      const now = state.lastTime || 0;
      const delta = state.momentumLastKillTime ? Math.max(0, now - state.momentumLastKillTime) : Infinity;
      state.momentumLastKillTime = now;
      let gain = 8 + Math.min(6, state.wave) * 0.8;
      if(delta < 0.5) gain += 18;
      else if(delta < 1.1) gain += 12;
      else if(delta < 2.5) gain += 6;
      else gain += 3;
      state.momentumChainGrace = 3.2;
      state.momentumCombo = Math.min(15, (state.momentumCombo || 0) + 1);
      gainMomentum(gain);
    }

    function updateMomentumState(dt){
      let changed = false;
      if(state.momentumActiveTimer > 0){
        const before = state.momentumActiveTimer;
        state.momentumActiveTimer = Math.max(0, state.momentumActiveTimer - dt);
        if(state.momentumActiveTimer !== before) changed = true;
        if(state.momentumActiveTimer === 0){
          state.momentumChainGrace = 2;
          changed = true;
        }
      } else if(state.momentumChainGrace > 0){
        const beforeGrace = state.momentumChainGrace;
        state.momentumChainGrace = Math.max(0, state.momentumChainGrace - dt);
        if(state.momentumChainGrace !== beforeGrace) changed = true;
        if(state.momentumChainGrace === 0 && state.momentumCombo > 0){
          state.momentumCombo = Math.max(0, state.momentumCombo - 1);
          if(state.momentumCombo > 0) state.momentumChainGrace = 1.4;
          changed = true;
        }
      } else if(state.momentum > 0){
        const beforeMomentum = state.momentum;
        state.momentum = Math.max(0, state.momentum - dt * state.momentumDecayRate);
        if(state.momentum !== beforeMomentum) changed = true;
        if(state.momentum === 0 && state.momentumCombo > 0){
          state.momentumCombo = 0;
          changed = true;
        }
      }
      if(changed) updateMomentumUI();
    }

    function computeCrowdReward(baseCash, baseHype){
      const wave = Math.max(1, state.wave);
      const streak = Math.max(0, state.crowdStreak || 0);
      const cash = Math.round(baseCash + wave * 4 + streak * 10);
      const hype = Math.round(baseHype + Math.min(60, wave * 2.2) + streak * 4);
      return { money: cash, hype };
    }

    const CROWD_REQUEST_TEMPLATES = [
      {
        key: 'flawless',
        name: 'Flawless Finish',
        describe: () => 'Keep every spectator safe by preventing leaks this wave.',
        reward: () => computeCrowdReward(40, 26),
        setup(tracker, s){ tracker.lifeLoss = 0; tracker.startLives = s.lives; },
        onEvent(tracker, event, data){
          if(event === 'lifeLost'){
            tracker.lifeLoss = (tracker.lifeLoss || 0) + (data?.amount || 1);
            return 'failed';
          }
          if(event === 'waveCleared' && (tracker.lifeLoss || 0) === 0) return 'complete';
        },
        progress(tracker){ return (tracker.lifeLoss || 0) > 0 ? 0 : 1; },
        activeHeadline: () => 'Hold the line!',
        activeText: () => 'No leaks allowed.',
        failHeadline: () => 'Crowd gasped‚Ä¶',
        failText: () => 'Leaks slipped through.',
        completeHeadline: () => 'Flawless!',
        completeText: () => 'The arena erupts!'
      },
      {
        key: 'blueprint',
        name: 'Blueprint Parade',
        describe: (s, tracker) => `Construct ${tracker.target} new tower${tracker.target > 1 ? 's' : ''} this wave.`,
        reward: () => computeCrowdReward(26, 20),
        setup(tracker, s){ tracker.builds = 0; tracker.target = Math.min(3, 1 + Math.floor(Math.max(1, s.wave) / 3)); if(tracker.target < 1) tracker.target = 1; },
        onEvent(tracker, event){ if(event === 'build'){ tracker.builds = (tracker.builds || 0) + 1; if(tracker.builds >= tracker.target) return 'complete'; } },
        progress(tracker){ return tracker.target ? Math.min(1, (tracker.builds || 0) / tracker.target) : 0; },
        activeHeadline: () => 'Showcase builds',
        activeText: tracker => `${tracker.builds || 0}/${tracker.target} constructed`,
        completeHeadline: () => 'Crowd loves it!',
        completeText: () => 'Fresh towers wowed the fans.',
        failHeadline: () => 'Designs delayed',
        failText: () => 'Build quota missed.'
      },
      {
        key: 'glowup',
        name: 'Glow-Up Routine',
        describe: (s, tracker) => `Upgrade ${tracker.target} tower${tracker.target > 1 ? 's' : ''} during the wave.`,
        reward: () => computeCrowdReward(32, 24),
        setup(tracker, s){ tracker.upgrades = 0; tracker.target = Math.min(4, Math.max(1, Math.floor(Math.max(1, s.wave) / 4))); },
        onEvent(tracker, event){ if(event === 'upgrade'){ tracker.upgrades = (tracker.upgrades || 0) + 1; if(tracker.upgrades >= tracker.target) return 'complete'; } },
        progress(tracker){ return tracker.target ? Math.min(1, (tracker.upgrades || 0) / tracker.target) : 0; },
        activeHeadline: () => 'Polish the arsenal',
        activeText: tracker => `${tracker.upgrades || 0}/${tracker.target} upgrades`,
        completeHeadline: () => 'Radiant towers!',
        completeText: () => 'Upgrades dazzled the stands.',
        failHeadline: () => 'Upgrades stalled',
        failText: () => 'No glow-up delivered.'
      },
      {
        key: 'hypeburst',
        name: 'Bring the Hype',
        describe: () => 'Trigger the hype burst at least once this wave.',
        reward: () => computeCrowdReward(34, 36),
        setup(tracker){ tracker.triggered = false; },
        available: () => state.wave >= 3,
        onEvent(tracker, event){ if(event === 'hype'){ tracker.triggered = true; return 'complete'; } if(event === 'waveCleared' && tracker.triggered) return 'complete'; },
        progress(tracker){ return tracker.triggered ? 1 : Math.min(0.95, state.hype / state.hypeMax || 0); },
        activeHeadline: () => 'Prime the anthem',
        activeText: tracker => tracker.triggered ? 'Burst unleashed!' : 'Crowd wants the drop.',
        completeHeadline: () => 'The drop hits!',
        completeText: () => 'Spectators go wild!',
        failHeadline: () => 'Crowd restless',
        failText: () => 'Hype burst never dropped.'
      },
      {
        key: 'style',
        name: 'Style Streak',
        describe: (s, tracker) => `Defeat ${tracker.target} enemies this wave to keep the hype alive.`,
        reward: () => computeCrowdReward(28, 22),
        setup(tracker, s){ tracker.kills = 0; tracker.target = Math.min(60, 12 + Math.floor(Math.max(1, s.wave) * 2.4)); },
        onEvent(tracker, event){ if(event === 'kill'){ tracker.kills = (tracker.kills || 0) + 1; if(tracker.kills >= tracker.target) return 'complete'; } },
        progress(tracker){ return tracker.target ? Math.min(1, (tracker.kills || 0) / tracker.target) : 0; },
        activeHeadline: () => 'Keep the combo',
        activeText: tracker => `${tracker.kills || 0}/${tracker.target} defeated`,
        completeHeadline: () => 'Combo complete!',
        completeText: () => 'Stylish elimination spree!',
        failHeadline: () => 'Combo dropped',
        failText: () => 'Need more eliminations.'
      }
    ];

    function beginCrowdRequest(){
      if(state.wave <= 0){
        state.crowdRequest = null;
        state.crowdTracker = null;
        updateCrowdUI();
        return;
      }
      const options = CROWD_REQUEST_TEMPLATES.filter(def => !def.available || def.available(state));
      if(options.length === 0){
        state.crowdRequest = null;
        state.crowdTracker = null;
        updateCrowdUI();
        return;
      }
      const idx = hashWaveIndex(state.wave * 37 + state.crowdStreak * 13) % options.length;
      const def = options[idx];
      const tracker = { wave: state.wave };
      if(typeof def.setup === 'function') def.setup(tracker, state);
      const desc = typeof def.describe === 'function' ? def.describe(state, tracker) : (def.description || 'The crowd demands a show.');
      const reward = typeof def.reward === 'function' ? def.reward(state, tracker) : computeCrowdReward(28, 22);
      state.crowdTracker = tracker;
      state.crowdRequest = { key: def.key, name: def.name, description: desc, reward, status: 'active', progress: 0, tracker, def, settled: false };
      notifyCrowd('waveStart');
    }

    function updateCrowdProgress(){
      if(!UI.crowdCard) return;
      const req = state.crowdRequest;
      if(!req){
        UI.crowdCard.classList.remove('success', 'failed');
        if(UI.crowdName) UI.crowdName.textContent = 'Crowd Request';
        if(UI.crowdDesc) UI.crowdDesc.textContent = 'Clear waves to unlock special requests from the roaring arena crowd.';
        if(UI.crowdReward) UI.crowdReward.textContent = 'Awaiting';
        if(UI.crowdMeter) UI.crowdMeter.style.width = '0%';
        if(UI.crowdStatus){ UI.crowdStatus.textContent = 'Awaiting wave'; UI.crowdStatus.classList.remove('warn', 'success'); }
        if(UI.crowdProgressLabel) UI.crowdProgressLabel.textContent = '0%';
        if(UI.crowdStreak) UI.crowdStreak.textContent = state.crowdStreak > 0 ? `üî• Streak ${state.crowdStreak}` : 'Streak 0';
        return;
      }
      if(UI.crowdName) UI.crowdName.textContent = req.name;
      if(UI.crowdDesc) UI.crowdDesc.textContent = req.description;
      if(UI.crowdReward) UI.crowdReward.textContent = `+$${req.reward.money} ‚Ä¢ +${req.reward.hype}‚ö°`;
      let progress = req.progress;
      let label = req.progressLabel || '';
      let headline = req.headline || '';
      if(req.status === 'active'){
        if(typeof req.def.progress === 'function'){
          const value = Number(req.def.progress(req.tracker, state, req));
          progress = Number.isFinite(value) ? Math.max(0, Math.min(1, value)) : 0;
          req.progress = progress;
        }
        if(typeof req.def.activeText === 'function') label = req.def.activeText(req.tracker, state, req);
        else label = `${Math.round((req.progress || 0) * 100)}%`;
        if(typeof req.def.activeHeadline === 'function') headline = req.def.activeHeadline(req.tracker, state, req);
        else headline = 'In progress';
      } else if(req.status === 'complete'){
        progress = 1;
        if(typeof req.def.completeText === 'function') label = req.def.completeText(req.tracker, state, req);
        else label = 'Completed!';
        if(typeof req.def.completeHeadline === 'function') headline = req.def.completeHeadline(req.tracker, state, req);
        else headline = 'Complete';
      } else if(req.status === 'failed'){
        progress = 0;
        if(typeof req.def.failText === 'function') label = req.def.failText(req.tracker, state, req);
        else label = 'Request failed';
        if(typeof req.def.failHeadline === 'function') headline = req.def.failHeadline(req.tracker, state, req);
        else headline = 'Failed';
      }
      req.progress = progress;
      req.progressLabel = label;
      req.headline = headline;
      if(UI.crowdMeter) UI.crowdMeter.style.width = `${Math.round(progress * 100)}%`;
      if(UI.crowdProgressLabel) UI.crowdProgressLabel.textContent = label;
      if(UI.crowdStatus){
        UI.crowdStatus.textContent = headline;
        UI.crowdStatus.classList.remove('warn', 'success');
        if(req.status === 'complete') UI.crowdStatus.classList.add('success');
        if(req.status === 'failed') UI.crowdStatus.classList.add('warn');
      }
      if(UI.crowdCard){
        UI.crowdCard.classList.toggle('success', req.status === 'complete');
        UI.crowdCard.classList.toggle('failed', req.status === 'failed');
      }
      if(UI.crowdStreak) UI.crowdStreak.textContent = state.crowdStreak > 0 ? `üî• Streak ${state.crowdStreak}` : 'Streak 0';
    }

    function updateCrowdUI(){
      updateCrowdProgress();
    }


    function grantCrowdReward(req){
      if(!req || !req.reward) return;
      if(req.reward.money){ state.money += req.reward.money; if(UI.money) UI.money.textContent = state.money; }
      if(req.reward.hype){ gainHype(req.reward.hype); }
      state.pulses.push({ x: W/2, y: H/2, r: 0, max: Math.max(W, H), ttl: 0.7, life: 0.7, color: '#facc15' });
    }

    function settleCrowdRequest(req, status){
      if(!req || req.settled) return;
      req.status = status;
      req.settled = true;
      if(status === 'complete'){
        state.crowdStreak = Math.min(10, (state.crowdStreak || 0) + 1);
        grantCrowdReward(req);
      } else if(status === 'failed'){
        state.crowdStreak = 0;
      }
      updateCrowdProgress();
    }

    function notifyCrowd(event, data){
      const req = state.crowdRequest;
      if(!req) return;
      if(event !== 'waveStart' && req.status !== 'active') return;
      if(event === 'waveStart'){
        if(req.def && typeof req.def.onStart === 'function') req.def.onStart(req.tracker, state, data);
        req.settled = false;
        req.status = 'active';
        updateCrowdProgress();
        return;
      }
      if(req.def && typeof req.def.onEvent === 'function'){
        const outcome = req.def.onEvent(req.tracker, event, data, state);
        if(outcome === 'complete'){ settleCrowdRequest(req, 'complete'); return; }
        if(outcome === 'failed'){ settleCrowdRequest(req, 'failed'); return; }
      }
      if(req.def){
        if(typeof req.def.complete === 'function' && req.def.complete(req.tracker, event, data, state)){ settleCrowdRequest(req, 'complete'); return; }
        if(typeof req.def.fail === 'function' && req.def.fail(req.tracker, event, data, state)){ settleCrowdRequest(req, 'failed'); return; }
      }
      if(event === 'waveCleared' && req.status === 'active'){ settleCrowdRequest(req, 'failed'); return; }
      updateCrowdProgress();
    }

    function activateHype(auto=false){
      if(state.hypeActiveTimer > 0 || state.hype < state.hypeMax) return false;
      state.hype -= state.hypeMax;
      state.hypeActiveTimer = state.hypeDuration;
      state.hypeReadyPinged = false;
      updateHypeUI();
      if(!auto) AudioSys.ensure();
      state.pulses.push({x: W/2, y: H/2, r: 0, max: Math.max(W,H), ttl: 0.6, life: 0.6, color:'#38bdf8'});
      notifyCrowd('hype');
      return true;
    }

    function updateHypeState(dt){
      if(state.hypeActiveTimer > 0){
        state.hypeActiveTimer = Math.max(0, state.hypeActiveTimer - dt * state.speedMultiplier);
        if(state.hypeActiveTimer === 0){
          updateHypeUI();
        }
      }
    }

    function handleKillBonuses(enemy){
      const mods = state.eventModifiers || BASE_EVENT_MODIFIERS;
      if(mods.killBonus) state.money += mods.killBonus;
      let hypeGain = 6 + (mods.hypeGainBonus || 0);
      if(enemy.kind === 'boss') hypeGain += 30;
      if(state.crowdStreak > 0) hypeGain += state.crowdStreak * 1.5;
      gainHype(hypeGain);
      handleMomentumKill(enemy);
    }

    function processEventTick(dt){
      if(!state.activeEvent || !state.activeEvent.def || typeof state.activeEvent.def.tick !== 'function') return;
      state.activeEvent.def.tick(state.activeEvent, dt);
    }

    function addLightningArc(points, color='#38bdf8'){
      if(!points || points.length < 2) return;
      state.lightning.push({ points, ttl: 0.18, life: 0.18, color });
    }

    function updateLightning(dt){
      for(let i=state.lightning.length-1;i>=0;i--){
        const bolt = state.lightning[i];
        bolt.ttl -= dt;
        if(bolt.ttl <= 0){ state.lightning.splice(i,1); }
      }
    }

    function updatePulses(dt){
      for(let i=state.pulses.length-1;i>=0;i--){
        const pulse = state.pulses[i];
        pulse.ttl -= dt;
        const progress = 1 - Math.max(0, pulse.ttl) / (pulse.life || 0.6);
        pulse.r = pulse.max * progress;
        if(pulse.ttl <= 0) state.pulses.splice(i,1);
      }
    }

    function gatherTowerModifiers(tower){
      const mods = state.eventModifiers || BASE_EVENT_MODIFIERS;
      let damageMult = mods.towerDamageMult || 1;
      let rateMult = mods.towerRateMult || 1;
      let rangeBonus = mods.towerRangeBonus || 0;
      let pierceBonus = 0;
      if(state.hypeActiveTimer > 0){
        damageMult *= 1.25;
        rateMult *= 0.6;
        rangeBonus += 6;
      }
      if(state.momentumActiveTimer > 0){
        const combo = Math.min(12, Math.max(1, state.momentumCombo || 1));
        damageMult *= 1.18 + combo * 0.015;
        rateMult *= Math.max(0.45, 0.72 - combo * 0.012);
        rangeBonus += 5 + combo * 1.1;
        pierceBonus += Math.max(0, Math.floor(combo / 4));
      } else if(state.momentumCombo > 0){
        const chain = Math.min(10, state.momentumCombo);
        damageMult *= 1 + chain * 0.01;
        rateMult *= Math.max(0.6, 1 - chain * 0.015);
        rangeBonus += chain * 0.8;
      }
      if(state.crowdStreak > 0){
        const streak = Math.min(6, state.crowdStreak);
        damageMult *= 1 + streak * 0.02;
        rateMult *= Math.max(0.5, 1 - streak * 0.035);
        rangeBonus += streak * 2;
      }
      for(const auraTower of state.towers){
        if(!auraTower || !auraTower.aura) continue;
        if(auraTower === tower && !auraTower.aura.affectSelf) continue;
        const auraRange = auraTower.aura.range || 0;
        const dist = Math.hypot(auraTower.x - tower.x, auraTower.y - tower.y);
        if(dist <= auraRange){
          if(auraTower.aura.damageMult) damageMult *= auraTower.aura.damageMult;
          if(auraTower.aura.rateMult) rateMult *= auraTower.aura.rateMult;
          if(auraTower.aura.rangeBonus) rangeBonus += auraTower.aura.rangeBonus;
          if(auraTower.aura.pierceBonus) pierceBonus += auraTower.aura.pierceBonus;
        }
      }
      return { damageMult, rateMult, rangeBonus, pierceBonus };
    }

    function findChainTarget(fromEnemy, visited, range){
      let best=null, bestDist=Infinity;
      for(const e of state.enemies){
        if(!e || !e.alive || visited.has(e)) continue;
        const dist = Math.hypot(e.pos.x - fromEnemy.pos.x, e.pos.y - fromEnemy.pos.y);
        if(dist <= range && dist < bestDist){
          best = e;
          bestDist = dist;
        }
      }
      return best;
    }

    function performChainLightning(tower, target, mods){
      if(!target || !target.alive) return;
      const visited = new Set();
      const points = [{x:tower.x, y:tower.y}];
      let current = target;
      let damage = Math.round((tower.damage || 0) * (mods.damageMult || 1));
      const bounces = Math.max(1, tower.chainTargets || 3);
      const falloff = tower.chainFalloff || 0.75;
      const range = tower.chainRange || tower.range;
      for(let i=0;i<bounces && current && damage>0;i++){
        visited.add(current);
        applyDamage(current, damage, { owner: tower, dmg: damage });
        points.push({ x: current.pos.x + (Math.random()*12-6), y: current.pos.y + (Math.random()*12-6) });
        damage = Math.round(damage * falloff);
        current = findChainTarget(current, visited, range);
      }
      if(points.length>1) addLightningArc(points, '#bef264');
    }

    function setSelectedTowerType(key, opts={}){
      const def = TOWER_TYPES[key] || TOWER_TYPES.basic;
      state.selectedTowerType = key;
      state.selectedTowerCost = def.cost;
      if(opts.activateBuild !== false){
        state.build = true;
        UI.buildMode.checked = true;
        state.selling = false;
        UI.sellMode.textContent = 'Sell Mode';
      }
      UI.towerShop.querySelectorAll('.tower-card').forEach(card => {
        const selected = card.dataset.tower === key;
        card.classList.toggle('selected', selected);
      });
      updateSelectedTowerInfo();
    }

    function buildShop(){
      UI.towerShop.innerHTML = '';
      Object.entries(TOWER_TYPES).forEach(([key, def]) => {
        const card = document.createElement('div');
        card.className = 'shop-card tower-card';
        card.dataset.tower = key;
        let stats;
        if(def.utility && def.aura){
          stats = [`Aura ${def.aura.range}`];
          if(def.aura.damageMult && def.aura.damageMult !== 1){
            stats.push(`Damage +${Math.round((def.aura.damageMult - 1) * 100)}%`);
          }
          if(def.aura.rateMult && def.aura.rateMult !== 1){
            const speed = def.aura.rateMult < 1 ? Math.round((1 - def.aura.rateMult) * 100) : -Math.round((def.aura.rateMult - 1) * 100);
            stats.push(`${speed >= 0 ? 'Speed +' : 'Speed '}${speed}%`);
          }
          if(def.aura.rangeBonus){
            stats.push(`Range +${Math.round(def.aura.rangeBonus)}`);
          }
        } else {
          stats = [`Range ${def.range}`, `Rate ${def.rate.toFixed(2)}s`, `Damage ${def.damage}`];
        }
        if((def.pierce||0) > 0) stats.push(`Pierce ${def.pierce+1}`);
        if(def.bullet && def.bullet.splashRadius) stats.push(`Splash ${def.bullet.splashRadius}`);
        card.innerHTML = `
          <div>
            <div class=\"tower-header\"><strong>${def.icon} ${def.name}</strong><span class=\"badge\">$${def.cost}</span></div>
            <div class=\"tower-meta\">${stats.join(' ‚Ä¢ ')}</div>
            <div style=\"color:#9aa3d7;font-size:13px;\">${def.description}</div>
          </div>
          <div><button class=\"btn\" data-tower=\"${key}\">Build</button></div>
        `;
        UI.towerShop.appendChild(card);
      });
      setSelectedTowerType(state.selectedTowerType, { activateBuild: false });
    }

    function updateAutoReportPanel(message){
      if(state.silenceAutoReport) return;
      if(message){
        UI.autoReport.textContent = message;
      }
      const stats = state.autoReport;
      if(!stats){
        UI.autoReportStatus.textContent = 'Idle';
        if(!message) UI.autoReport.textContent = 'Toggle auto-play to let the AI experiment and gather tuning data.';
        return;
      }
      if(stats.active) UI.autoReportStatus.textContent = 'Running';
      else if(stats.endedWithGameOver) UI.autoReportStatus.textContent = 'Game Over';
      else UI.autoReportStatus.textContent = 'Paused';
      if(stats.wavesCompleted === 0){
        if(!message) UI.autoReport.textContent = stats.active ? 'Auto-play is collecting data‚Ä¶ clear a wave to see insights.' : 'No data yet. Let the AI finish a wave.';
        return;
      }
      const avgLives = (stats.totalLives / stats.wavesCompleted).toFixed(1);
      const avgMoney = Math.round(stats.totalMoneyDelta / stats.wavesCompleted);
      const tension = stats.livesLostTotal / stats.wavesCompleted;
      let fun = 'Balanced';
      if(tension <= 0.2) fun = 'Too easy';
      else if(tension >= 1.8) fun = 'Punishing';
      else if(tension >= 1.1) fun = 'Challenging';
      const last = stats.waves[stats.waves.length-1];
      const recent = stats.waves.slice(-3).map(w=>`#${w.wave}: -${w.livesLost}‚ù§Ô∏è, Œî$${w.netMoney}`).join('\\n');
      const duration = stats.runDuration != null ? stats.runDuration : (stats.runStartTime ? Math.round((performance.now()-stats.runStartTime)/1000) : null);
      const lines = [
        `Run started wave ${stats.startedAtWave + 1}`,
        `Waves cleared: ${stats.wavesCompleted}`,
        `Avg lives remaining: ${avgLives}`,
        `Avg cash delta: $${avgMoney}`,
        `Fun rating: ${fun}`
      ];
      if(duration != null) lines.push(`Run duration: ${duration}s`);
      lines.push('', `Last wave #${last.wave}`, ` ‚Ä¢ Lives lost: ${last.livesLost}`, ` ‚Ä¢ Cash change: $${last.netMoney}`, ` ‚Ä¢ Towers in play: ${last.towers}`, '', 'Recent waves:', recent || '(pending)');
      UI.autoReport.textContent = lines.join('\\n');
    }

    function beginAutoReport(){
      state.autoReport = {
        active: true,
        startedAtWave: state.wave,
        lastRecordedWave: state.wave,
        lastLives: state.lives,
        lastMoney: state.money,
        totalLives: 0,
        totalMoneyDelta: 0,
        livesLostTotal: 0,
        wavesCompleted: 0,
        waves: [],
        runStartTime: performance.now(),
        endedWithGameOver: false,
        runDuration: null
      };
      if(!state.autoStart){ state.autoStart = true; UI.autoStart.checked = true; }
      if(state.wave===0 && state.enemies.length===0 && state.wavePlan.length===0){
        startWave();
      }
      updateAutoReportPanel('Auto-play engaged. The AI will log how the run feels.');
    }

    function finishAutoReport(reason){
      if(!state.autoReport) return;
      state.autoReport.active = false;
      if(reason === 'gameover') state.autoReport.endedWithGameOver = true;
      if(state.autoReport.runStartTime){ state.autoReport.runDuration = Math.round((performance.now()-state.autoReport.runStartTime)/1000); }
      updateAutoReportPanel();
    }

    function recordAutoPlayWave(waveNumber){
      const stats = state.autoReport;
      if(!stats || !stats.active) return;
      if(stats.lastRecordedWave === waveNumber) return;
      const livesLost = Math.max(0, stats.lastLives - state.lives);
      const netMoney = state.money - stats.lastMoney;
      stats.totalLives += state.lives;
      stats.totalMoneyDelta += netMoney;
      stats.livesLostTotal += livesLost;
      stats.wavesCompleted++;
      stats.bestWave = Math.max(stats.bestWave || 0, waveNumber);
      stats.waves.push({ wave: waveNumber, livesLost, netMoney, towers: state.towers.length });
      stats.lastLives = state.lives;
      stats.lastMoney = state.money;
      stats.lastRecordedWave = waveNumber;
      updateAutoReportPanel();
    }

    function resetInteractiveState(){
      state.money = 120;
      state.lives = 20;
      state.wave = 0;
      state.enemies = [];
      state.towers = [];
      state.bullets = [];
      state.wavePlan = [];
      state.waveClock = 0;
      state.kills = 0;
      state.totalEarned = 0;
      state.towersBuilt = 0;
      state.gameOver = false;
      state.waveClearedBonusGiven = false;
      state.difficulty = 'Normal';
      state.speedMultiplier = 1;
      state.autoStart = false;
      state.autoPlay = false;
      state.aiPlaceCooldown = 0;
      state.aiUpgradeCooldown = 0;
      state.selected = null;
      state.lastTime = 0;
      state.autoReport = null;
      state.silenceAutoReport = false;
      state.selling = false;
      state.build = false;
      state.debugVisible = false;
      state.lightning.length = 0;
      state.pulses.length = 0;
      state.hype = 0;
      state.hypeActiveTimer = 0;
      state.hypeReadyPinged = false;
      state.momentum = 0;
      state.momentumActiveTimer = 0;
      state.momentumChainGrace = 0;
      state.momentumCombo = 0;
      state.momentumLastKillTime = 0;
      state.crowdRequest = null;
      state.crowdTracker = null;
      state.crowdStreak = 0;
      resetEventModifiers();
      state.activeEvent = null;
      UI.startWave.disabled = false;
      UI.money.textContent = state.money;
      UI.lives.textContent = state.lives;
      UI.wave.textContent = state.wave;
      UI.enemies.textContent = 0;
      UI.difficulty.value = 'Normal';
      UI.speedBtn.textContent = 'Speed: 1x';
      UI.modeIndicator.textContent = 'Normal ‚Ä¢ 1x';
      UI.autoStart.checked = false;
      UI.autoPlayBtn.textContent = 'Auto-Play: Off';
      UI.buildMode.checked = false;
      UI.sellMode.textContent = 'Sell Mode';
      UI.autoReportStatus.textContent = 'Idle';
      UI.autoReport.textContent = 'Toggle auto-play to let the AI experiment and gather tuning data.';
      UI.debugPanel.classList.remove('active');
      UI.debugToggle.textContent = 'Show Debug Tools';
      UI.soundBtn.textContent = `Sound: ${AudioSys.isEnabled() ? 'On' : 'Off'}`;
      setSelectedTowerType('basic', { activateBuild: false });
      updateEventUI();
      updateHypeUI();
      updateMomentumUI();
      updateCrowdUI();
    }
    const AudioSys = (()=>{ let actx=null, enabled=true; function ensure(){ try{ if(!actx) actx=new (window.AudioContext||window.webkitAudioContext)(); if(actx.state==='suspended') actx.resume(); }catch(e){} } function blip({freq=520, dur=0.06, vol=0.05, type='triangle'}={}){ if(!enabled) return; ensure(); if(!actx) return; const t=actx.currentTime; const o=actx.createOscillator(); const g=actx.createGain(); o.type=type; o.frequency.setValueAtTime(freq,t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+0.005); g.gain.exponentialRampToValueAtTime(0.0001,t+dur); o.connect(g).connect(actx.destination); o.start(t); o.stop(t+dur+0.03); } function towerFire(){ blip({freq:760+Math.random()*100,dur:0.04,vol:0.06,type:'square'}); } const enemyHitSounds={ grunt: ()=>blip({freq:380+Math.random()*40,dur:0.05,vol:0.045,type:'triangle'}), fast: ()=>blip({freq:520+Math.random()*60,dur:0.04,vol:0.04,type:'sawtooth'}), tank: ()=>blip({freq:240+Math.random()*30,dur:0.07,vol:0.06,type:'sine'}), healer:()=>blip({freq:640+Math.random()*50,dur:0.05,vol:0.04,type:'triangle'}), rich: ()=>blip({freq:660,dur:0.06,vol:0.05,type:'square'}), boss: ()=>blip({freq:180,dur:0.1,vol:0.08,type:'sine'}), }; function onEnemyHit(kind){ const f=enemyHitSounds[kind]||enemyHitSounds.grunt; f(); } function toggle(){ enabled=!enabled; UI.soundBtn.textContent=`Sound: ${enabled?'On':'Off'}`; ensure(); } function isEnabled(){ return enabled; } return { ensure, towerFire, onEnemyHit, toggle, isEnabled }; })();
    window.addEventListener('pointerdown', ()=>AudioSys.ensure(), {once:true, passive:true});

    const assets = { bgImg:null };
    (function setDefaultBG(){ const svg = encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='800' height='480'><defs><radialGradient id='g' cx='50%' cy='50%'><stop offset='0%' stop-color='#0b1430'/><stop offset='100%' stop-color='#060a1a'/></radialGradient></defs><rect width='100%' height='100%' fill='url(#g)'/>${Array.from({length:120}).map(()=>{ const x=Math.random()*800|0, y=Math.random()*480|0, r=(Math.random()*1.4+0.3).toFixed(2); return `<circle cx='${x}' cy='${y}' r='${r}' fill='white' opacity='${(Math.random()*0.9+0.1).toFixed(2)}'/>`; }).join('')}</svg>`); const img = new Image(); img.src = `data:image/svg+xml;charset=utf-8,${svg}`; assets.bgImg = img; })();

    const waypoints = [ {x:0,y:GRID*2}, {x:GRID*6,y:GRID*2}, {x:GRID*6,y:GRID*8}, {x:GRID*12,y:GRID*8}, {x:GRID*12,y:GRID*3}, {x:GRID*19.5,y:GRID*3} ];
    const segmentLengths=[], segmentPrefix=[0];
    (function(){ for(let i=0;i<waypoints.length-1;i++){ const a=waypoints[i], b=waypoints[i+1]; const len=Math.hypot(b.x-a.x,b.y-a.y); segmentLengths.push(len); segmentPrefix.push(segmentPrefix[i]+len);} })();

    function distToPath(x,y){ let best=Infinity; for(let i=0;i<waypoints.length-1;i++){ const a=waypoints[i], b=waypoints[i+1]; const vx=b.x-a.x, vy=b.y-a.y, wx=x-a.x, wy=y-a.y; const c1=vx*wx+vy*wy; if(c1<=0){ best=Math.min(best,Math.hypot(x-a.x,y-a.y)); continue; } const c2=vx*vx+vy*vy; if(c2<=c1){ best=Math.min(best,Math.hypot(x-b.x,y-b.y)); continue; } const t=c1/c2; const px=a.x+t*vx, py=a.y+t*vy; best=Math.min(best,Math.hypot(x-px,y-py)); } return best; }
    function blockPath(){ const halfPath=14; const pad=6; const thresh=halfPath+pad; for(let gx=0;gx<W/GRID;gx++){ for(let gy=0;gy<H/GRID;gy++){ const cx=gx*GRID+GRID/2, cy=gy*GRID+GRID/2; if(distToPath(cx,cy) < thresh) state.blocked.add(`${gx},${gy}`); } } }
    blockPath();

    function diff(){ if(state.difficulty==='Easy') return {hp:0.85, spd:0.9, count:0.85}; if(state.difficulty==='Hard') return {hp:1.25, spd:1.1, count:1.25}; return {hp:1.0, spd:1.0, count:1.0}; }

    const ENEMY_TYPES = {
      grunt: { icon: ()=>"üëæ", baseHp: 40, baseSpd: 55, reward:10, onDeath:null },
      fast:  { icon: ()=>"üí®", baseHp: 25, baseSpd: 100, reward:12, onDeath:null },
      tank:  { icon: ()=>"üõ°Ô∏è", baseHp: 120, baseSpd: 40, reward:20, onDeath:null },
      healer:{ icon: ()=>"‚ù§Ô∏è", baseHp: 35, baseSpd: 50, reward:5, onDeath:(s)=>{ s.lives += 1; } },
      rich:  { icon: ()=>"üí≤", baseHp: 30, baseSpd: 55, reward:30, onDeath:null },
      boss:  { icon: ()=>"üêâ", baseHp: 600, baseSpd: 38, reward:80, onDeath:null }
    };

    function waveHpScale(){ const w=Math.max(0,state.wave-1); return (1 + w * BAL.hpLinearSlope) * (1 + Math.floor(w/BAL.hpPeriodicEvery) * BAL.hpPeriodicStep); }

    class Enemy{
      constructor(kind){ const t=ENEMY_TYPES[kind]||ENEMY_TYPES.grunt; const d=diff(); const w=waveHpScale(); const mods=state.eventModifiers||BASE_EVENT_MODIFIERS; this.kind=kind; this.icon=t.icon; this.baseSpeed=(t.baseSpd)*d.spd*Math.max(0.9, 1 + (state.wave-1)*0.02)*(mods.enemySpeedMult||1); this.speed=this.baseSpeed; this.hp=(t.baseHp)*d.hp*w*(mods.enemyHpMult||1); this.maxHp=this.hp; this.armor = Math.max(0, (state.wave-1)*BAL.armorPerWave + (kind==='tank'?BAL.armorTank:0) +(kind==='boss'?BAL.armorBoss:0)); this.reward=Math.round(t.reward*(1 + BAL.rewardSlope*Math.max(0,state.wave-1))*(mods.enemyRewardMult||1)); this.onDeath=t.onDeath; this.pos={x:waypoints[0].x,y:waypoints[0].y}; this.seg=0; this.t=0; this.progress=0; this.alive=true; this.slowTimer=0; this.slowFactor=1; }
      getRadius(){ const minR=12,maxR=(this.kind==='boss'?40:26); const f=Math.max(0,Math.min(1,this.hp/this.maxHp)); const eased=Math.pow(f,4); return minR+(maxR-minR)*eased; }
      applySlow(factor,duration){ if(!factor || factor>=1 || !duration) return; if(this.slowTimer>0){ this.slowFactor=Math.min(this.slowFactor,factor); this.slowTimer=Math.max(this.slowTimer,duration); } else { this.slowFactor=factor; this.slowTimer=duration; } }
      update(dt){ if(!this.alive) return; this.slowTimer=Math.max(0,this.slowTimer-dt); if(this.slowTimer<=0) this.slowFactor=1; this.speed=this.baseSpeed*(this.slowTimer>0?this.slowFactor:1); let dtr=dt; while(dtr>0 && this.alive){ const a=waypoints[this.seg], b=waypoints[this.seg+1]; if(!b){ this.alive=false; const leak=(this.kind==='boss'?BAL.bossLeakLives:1); state.lives -= leak; notifyCrowd('lifeLost', { amount: leak, enemy: this }); shatterMomentum(leak); if(state.lives<=0) state.gameOver=true; return; } const segLen=segmentLengths[this.seg]; const step=Math.min(dtr*this.speed, segLen-this.t); this.t+=step; const r=this.t/segLen; this.pos.x=a.x+(b.x-a.x)*r; this.pos.y=a.y+(b.y-a.y)*r; this.progress=segmentPrefix[this.seg]+this.t; dtr-=step/this.speed; if(this.t>=segLen-0.0001){ this.seg++; this.t=0; } } }
      hit(dmg){ const eff = Math.max(1, dmg - (this.armor||0)); this.hp-=eff; AudioSys.onEnemyHit(this.kind); if(this.hp<=0 && this.alive){ this.alive=false; state.money+=this.reward; if(this.onDeath) this.onDeath(state); } }
      draw(ctx){ if(!this.alive) return; const R=this.getRadius(); ctx.font=`${Math.floor(R*1.8)}px system-ui, apple color emoji, segoe ui emoji`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(this.icon(), this.pos.x, this.pos.y+1); const w=26,h=5,ox=-13,oy=-R-14; ctx.fillStyle='#1f2a44'; ctx.fillRect(this.pos.x+ox,this.pos.y+oy,w,h); ctx.fillStyle='#ef4444'; ctx.fillRect(this.pos.x+ox,this.pos.y+oy,w*(this.hp/this.maxHp),h); if(this.slowTimer>0){ ctx.strokeStyle='rgba(56,189,248,0.55)'; ctx.beginPath(); ctx.arc(this.pos.x,this.pos.y,R+6,0,Math.PI*2); ctx.stroke(); } }
    }

    class Tower{
      constructor(x,y,typeKey){ const def=TOWER_TYPES[typeKey]||TOWER_TYPES.basic; this.x=x; this.y=y; this.type=typeKey; this.def=def; this.range=def.range; this.cooldown=0; this.rate=def.rate; this.damage=def.damage; this.level=1; this.totalDamage=0; this.upgradeCost=Math.round(def.cost*1.35); this.sellValue=Math.floor(def.cost*0.7); this.pierce=def.pierce||0; this.icon=def.icon||'üõ∞Ô∏è'; this.color=def.color||'#5b72ff'; this.bullet=JSON.parse(JSON.stringify(def.bullet||{})); this.utility=!!def.utility; this.aura=def.aura?JSON.parse(JSON.stringify(def.aura)):null; this.chainTargets=def.chainTargets||0; this.chainRange=def.chainRange||def.range; this.chainFalloff=def.chainFalloff||0.75; }
      canUpgrade(){ return this.level < (this.def.maxLevel || 10); }
      upgrade(){ if(!this.canUpgrade()) return false; if(state.money < this.upgradeCost) return false; state.money -= this.upgradeCost; this.level++; if(typeof this.def.upgrade === 'function') this.def.upgrade(this); else { this.damage=Math.round(this.damage*1.25); this.rate=Math.max(0.18, +(this.rate*0.92).toFixed(2)); this.range=Math.min(240, this.range+12); if(this.level%3===0) this.pierce++; } this.upgradeCost=Math.round(this.upgradeCost*(this.def.upgradeCostGrowth||1.6)); this.sellValue=Math.floor(this.sellValue+this.upgradeCost*0.3); notifyCrowd('upgrade', { tower: this }); return true; }
      fire(target, mods={}){ const damage = Math.max(1, Math.round((this.damage||0) * (mods.damageMult||1))); const pierce = (this.pierce||0) + (mods.pierceBonus||0); spawnProjectile(this,target,{damage,pierce}); }
      update(dt){ if(this.utility){ if(typeof this.def.utilityUpdate === 'function') this.def.utilityUpdate(this, dt); return; } const mods=gatherTowerModifiers(this); if(this.cooldown>0) this.cooldown-=dt; let target=null, best=-1; const effectiveRange=this.range+(mods.rangeBonus||0); for(const e of state.enemies){ if(!e.alive) continue; const d=Math.hypot(e.pos.x-this.x, e.pos.y-this.y); if(d<=effectiveRange && e.progress>best){ best=e.progress; target=e; } } if(typeof this.def.acquireTarget === 'function'){ target = this.def.acquireTarget(this, state.enemies, effectiveRange) || target; } if(target && this.cooldown<=0){ if(typeof this.def.fire === 'function') this.def.fire(this, target, mods); else this.fire(target, mods); const mult=Math.max(0.1, mods.rateMult||1); this.cooldown=Math.max(0.05, this.rate*mult); } if(typeof this.def.customUpdate === 'function') this.def.customUpdate(this, dt, mods); }
      draw(ctx){ ctx.save(); ctx.translate(this.x,this.y); ctx.globalAlpha=0.95; ctx.fillStyle= state.selected===this ? '#9aa8ff' : this.color; ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='24px system-ui, apple color emoji, segoe ui emoji'; ctx.fillText(this.icon,0,2); ctx.restore(); if(this.def && typeof this.def.postDraw === 'function') this.def.postDraw(this, ctx); if(state.build||state.selling||state.selected===this){ const range = this.utility && this.aura ? this.aura.range : this.range; ctx.strokeStyle= state.selected===this ? 'rgba(255,255,255,.35)' : 'rgba(147,162,255,.18)'; ctx.beginPath(); ctx.arc(this.x,this.y,range+(state.build||state.selling?0:0),0,Math.PI*2); ctx.stroke(); } }
    }

    function spawnProjectile(tower, target, overrides={}){
      const cfg = Object.assign({}, tower.bullet, overrides);
      const angle = Math.atan2(target.pos.y - tower.y, target.pos.x - tower.x);
      const speed = cfg.speed || 360;
      state.bullets.push({
        x: tower.x,
        y: tower.y,
        vx: Math.cos(angle)*speed,
        vy: Math.sin(angle)*speed,
        dmg: cfg.damage ?? tower.damage,
        ttl: cfg.ttl ?? 2,
        owner: tower,
        r: cfg.r ?? 3.5,
        pierce: cfg.pierce ?? tower.pierce,
        splashRadius: cfg.splashRadius || 0,
        splashFalloff: cfg.splashFalloff ?? 0.6,
        slow: cfg.slow || null,
        color: cfg.color || '#e5e7eb'
      });
      AudioSys.towerFire();
    }

    function applyDamage(enemy, damage, bullet){ if(!enemy || !enemy.alive) return; enemy.hit(damage); if(bullet && bullet.slow) enemy.applySlow(bullet.slow.factor, bullet.slow.duration); if(bullet && bullet.owner) bullet.owner.totalDamage += damage; if(!enemy.alive){ state.kills++; state.totalEarned += enemy.reward; handleKillBonuses(enemy); notifyCrowd('kill', { enemy, bullet }); } }

    function applySplashDamage(bullet, primaryEnemy, primaryIndex){ const radius = bullet.splashRadius; if(!radius) return; const dmg = Math.max(1, Math.round(bullet.dmg * (bullet.splashFalloff ?? 0.6))); for(let j=0;j<state.enemies.length;j++){ if(j===primaryIndex) continue; const other=state.enemies[j]; if(!other||!other.alive) continue; const dist=Math.hypot(other.pos.x-primaryEnemy.pos.x, other.pos.y-primaryEnemy.pos.y); if(dist<=radius){ applyDamage(other, dmg, bullet); } } }

    function segmentCircleAllHits(x1,y1,x2,y2,enemies,bulletR){ const hits=[]; const dx=x2-x1, dy=y2-y1, denom=dx*dx+dy*dy; for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(!e||!e.alive) continue; const cx=e.pos.x, cy=e.pos.y; const R=(e.getRadius?e.getRadius():12)+(bulletR||3); let t=0; if(denom>0){ t=((cx-x1)*dx+(cy-y1)*dy)/denom; if(t<0)t=0; else if(t>1)t=1; } const px=x1+dx*t, py=y1+dy*t; const d2=(px-cx)*(px-cx)+(py-cy)*(py-cy); if(d2<=R*R) hits.push({i,t}); } hits.sort((a,b)=>a.t-b.t); return hits; }

    canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); state.mouse={x:e.clientX-r.left,y:e.clientY-r.top}; });
    function worldToGrid(x,y){ return {gx:Math.floor(x/GRID), gy:Math.floor(y/GRID)}; }
    function gridToWorld(gx,gy){ return {x:gx*GRID+GRID/2, y:gy*GRID+GRID/2}; }
    function canPlaceAt(gx,gy){ if(gx<0||gy<0||gx>=W/GRID||gy>=H/GRID) return false; if(state.blocked.has(`${gx},${gy}`)) return false; for(const t of state.towers){ const g=worldToGrid(t.x,t.y); if(g.gx===gx&&g.gy===gy) return false; } const pos=gridToWorld(gx,gy); const minDist = 14 + 18 + 2; if(distToPath(pos.x,pos.y) < minDist) return false; return true; }
    canvas.addEventListener('click', e=>{ if(state.gameOver) return; const r=canvas.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; const {gx,gy}=worldToGrid(x,y); if(state.selling){ for(let i=0;i<state.towers.length;i++){ const t=state.towers[i]; const tg=worldToGrid(t.x,t.y); if(tg.gx===gx&&tg.gy===gy){ state.money+=t.sellValue; state.towers.splice(i,1); return; } } return; } if(state.build){ const def=TOWER_TYPES[state.selectedTowerType]||TOWER_TYPES.basic; const cost=def.cost; if(state.money>=cost && canPlaceAt(gx,gy)){ const pos=gridToWorld(gx,gy); const t=new Tower(pos.x,pos.y,state.selectedTowerType); state.towers.push(t); state.towersBuilt++; state.money-=cost; notifyCrowd('build', { tower: t, auto: false }); } return; } });

    UI.towerShop.addEventListener('click', e=>{ const target=e.target.closest('[data-tower]'); if(!target) return; const key=target.dataset.tower; setSelectedTowerType(key); AudioSys.ensure(); });

    UI.buildMode.addEventListener('change', ()=>{ state.build=UI.buildMode.checked; if(state.build){ state.selling=false; UI.sellMode.textContent='Sell Mode'; } updateSelectedTowerInfo(); });
    UI.sellMode.addEventListener('click', ()=>{ state.selling=!state.selling; if(state.selling){ state.build=false; UI.buildMode.checked=false; UI.sellMode.textContent='Selling‚Ä¶ click a tower'; } else UI.sellMode.textContent='Sell Mode'; });
    UI.startWave.addEventListener('click', ()=>{ AudioSys.ensure(); startWave(); });
    UI.difficulty.addEventListener('change', ()=>{ state.difficulty=UI.difficulty.value; UI.modeIndicator.textContent=`${state.difficulty} ‚Ä¢ ${state.speedMultiplier}x`; });
    UI.speedBtn.addEventListener('click', ()=>{ const next = state.speedMultiplier % 9 + 1; state.speedMultiplier = next; UI.speedBtn.textContent=`Speed: ${state.speedMultiplier}x`; UI.modeIndicator.textContent=`${state.difficulty} ‚Ä¢ ${state.speedMultiplier}x`; });
    UI.autoStart.addEventListener('change', ()=>{ state.autoStart=UI.autoStart.checked; });
    UI.autoPlayBtn.addEventListener('click', ()=>{ state.autoPlay=!state.autoPlay; UI.autoPlayBtn.textContent=`Auto-Play: ${state.autoPlay?'On':'Off'}`; if(state.autoPlay) beginAutoReport(); else finishAutoReport(); });
    UI.soundBtn.addEventListener('click', ()=>{ AudioSys.toggle(); });
    UI.hypeBtn.addEventListener('click', ()=>{ activateHype(false); });
    UI.debugToggle.addEventListener('click', ()=>{ state.debugVisible=!state.debugVisible; UI.debugPanel.classList.toggle('active', state.debugVisible); UI.debugToggle.textContent = state.debugVisible ? 'Hide Debug Tools' : 'Show Debug Tools'; });
    UI.copyLog.addEventListener('click', async () => { const txt = (UI.simOut.textContent || '').trim(); const payload = txt ? txt : '[No results yet]'; try { await navigator.clipboard.writeText(payload); UI.copyLog.textContent = 'Copied!'; setTimeout(()=> UI.copyLog.textContent='Copy Log', 1200); } catch(e){ const ta=document.createElement('textarea'); ta.value=payload; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); UI.copyLog.textContent='Copied!'; setTimeout(()=> UI.copyLog.textContent='Copy Log', 1200);} finally{ document.body.removeChild(ta);} } });

    function nearTurnTiles(){ const tiles=[]; for(let i=1;i<waypoints.length-1;i++){ const p=waypoints[i]; for(let dx=-2;dx<=2;dx++) for(let dy=-2;dy<=2;dy++){ const gx=Math.floor(p.x/GRID)+dx, gy=Math.floor(p.y/GRID)+dy; if(canPlaceAt(gx,gy)){ const pos=gridToWorld(gx,gy); tiles.push({gx,gy,x:pos.x,y:pos.y,score:Math.hypot(pos.x-p.x,pos.y-p.y)});} } } tiles.sort((a,b)=>a.score-b.score); return tiles; }
    let aiCandidates=nearTurnTiles();
    function countTowersOf(type){ let n=0; for(const t of state.towers){ if(t.type===type) n++; } return n; }
    function aiChooseTowerType(){ const wave=Math.max(1,state.wave); const counts={ basic:countTowersOf('basic'), pulse:countTowersOf('pulse'), frost:countTowersOf('frost'), sniper:countTowersOf('sniper') }; const order=[]; if(wave>=4 && counts.frost<1) order.push('frost'); if(wave>=6 && counts.pulse<Math.ceil(wave/5)) order.push('pulse'); if(wave>=8 && counts.sniper<Math.ceil(wave/6)) order.push('sniper'); if(wave>=10 && counts.pulse<Math.ceil(wave/4)) order.push('pulse'); order.push('basic'); for(const key of order){ const def=TOWER_TYPES[key]; if(def && state.money>=def.cost) return key; } let fallback=null; for(const [key,def] of Object.entries(TOWER_TYPES)){ if(state.money>=def.cost && (!fallback || def.cost<fallback.cost)) fallback={key,cost:def.cost}; } return fallback?fallback.key:null; }
    function aiTryPlace(){ if(state.aiPlaceCooldown>0) return; const typeKey=aiChooseTowerType(); if(!typeKey) return; const def=TOWER_TYPES[typeKey]; const cost=def.cost; const cap=BAL.desiredTowersCap; const desired=(BAL.aiBaseDesired|0)+Math.floor(state.wave/3); if(state.towers.length>=Math.min(cap,desired)) return; if(aiCandidates.length===0) aiCandidates=nearTurnTiles(); for(let i=0;i<aiCandidates.length;i++){ const c=aiCandidates[i]; if(!canPlaceAt(c.gx,c.gy)) continue; const pos=gridToWorld(c.gx,c.gy); let ok=true; for(const t of state.towers){ if(Math.hypot(t.x-pos.x,t.y-pos.y)<34){ ok=false; break; } } if(!ok) continue; if(state.money<cost) continue; const tower=new Tower(pos.x,pos.y,typeKey); state.towers.push(tower); state.towersBuilt++; state.money-=cost; notifyCrowd('build', { tower, auto: true }); state.aiPlaceCooldown=Math.max(0.2, BAL.aiCooldown||0.35); return; } }
    function aiTryUpgrade(){ if(state.aiUpgradeCooldown>0 || state.towers.length===0) return; let best=null; for(const t of state.towers){ if(!t.canUpgrade()) continue; if(!best || t.totalDamage>best.totalDamage) best=t; } if(best && state.money>=best.upgradeCost){ best.upgrade(); state.aiUpgradeCooldown=0.6; } }

    const WAVES = [
      [ {type:'grunt', count:6, spacing:0.7} ],
      [ {type:'grunt', count:6, spacing:0.6}, {type:'fast', count:4, spacing:0.5} ],
      [ {type:'tank', count:3, spacing:1.1}, {type:'grunt', count:4, spacing:0.6} ],
      [ {type:'grunt', count:6, spacing:0.6}, {type:'healer', count:2, spacing:1.0}, {type:'rich', count:1, spacing:1.5} ],
      [ {type:'fast', count:8, spacing:0.45}, {type:'tank', count:2, spacing:1.2} ],
      [ {type:'grunt', count:10, spacing:0.5}, {type:'healer', count:3, spacing:0.9} ]
    ];

    function generateWavePlan(idx){ const def=WAVES[idx % WAVES.length]; const plan=[]; let t=0; const countScale = 1 + idx*BAL.countSlope; for(const g of def){ const scaled = Math.max(1, Math.floor(g.count * countScale)); for(let i=0;i<scaled;i++){ plan.push({ time:t, type:g.type }); t+=g.spacing; } t+=0.6; } if(idx>=1){ const bosses = 1 + Math.floor(idx/BAL.bossEvery); for(let i=0;i<bosses;i++){ t+=0.8; plan.push({ time:t, type:'boss' }); } } return plan; }

    function startWave(){ if(state.gameOver) return; state.wave++; applyWaveEvent(); beginCrowdRequest(); const basePlan=generateWavePlan(state.wave-1); state.wavePlan = basePlan; state.waveClock=0; state.enemiesRemaining=basePlan.length; state.waveClearedBonusGiven=false; UI.startWave.disabled=true; }
    function spawnDue(dt){ state.waveClock += dt * state.speedMultiplier; while(state.wavePlan.length && state.wavePlan[0].time <= state.waveClock){ const evt=state.wavePlan.shift(); const e=new Enemy(evt.type); state.enemies.push(e); state.enemiesRemaining--; } }

    function update(dt){ if(state.gameOver){ if(state.autoReport && state.autoReport.active) finishAutoReport('gameover'); return; } const sdt=Math.min(0.05, dt*state.speedMultiplier); processEventTick(sdt); let waveJustCleared=false; let clearedWaveIndex=null; if(state.enemiesRemaining>0 || state.wavePlan.length>0){ spawnDue(sdt); } else if(state.enemies.length===0 && state.wave>0){ if(!state.waveClearedBonusGiven){ state.money += BAL.clearBase + Math.floor(state.wave*BAL.clearPer); state.waveClearedBonusGiven=true; clearWaveEvent(); } if(state.crowdRequest && state.crowdRequest.status === 'active') notifyCrowd('waveCleared', { wave: state.wave }); UI.startWave.disabled=false; waveJustCleared=true; clearedWaveIndex=state.wave; if(state.autoStart) startWave(); }
      if(state.autoPlay){ state.aiPlaceCooldown=Math.max(0,state.aiPlaceCooldown-sdt); state.aiUpgradeCooldown=Math.max(0,state.aiUpgradeCooldown-sdt); aiTryPlace(); aiTryUpgrade(); if(state.enemies.length===0 && state.enemiesRemaining===0 && !state.gameOver && state.wave>0 && state.autoStart===false) startWave(); }
      for(const e of state.enemies) e.update(sdt); state.enemies = state.enemies.filter(e=>e.alive);
      for(const t of state.towers) t.update(sdt);
      for(let i=state.bullets.length-1;i>=0;i--){ const b=state.bullets[i]; const nx=b.x+b.vx*sdt, ny=b.y+b.vy*sdt; b.ttl-=sdt; const hits=segmentCircleAllHits(b.x,b.y,nx,ny,state.enemies,b.r); if(hits.length>0){ const maxHits=1+(b.pierce||0); let applied=0; const hitSet=new Set(); for(const h of hits){ const e=state.enemies[h.i]; if(!e||!e.alive||hitSet.has(h.i)) continue; applyDamage(e, b.dmg, b); if(b.splashRadius) applySplashDamage(b, e, h.i); hitSet.add(h.i); applied++; if(applied>=maxHits) break; } if(applied>=maxHits){ state.bullets.splice(i,1); continue; } }
        if(b.ttl<=0){ state.bullets.splice(i,1); continue; }
        b.x=nx; b.y=ny;
      }
      updateLightning(sdt);
      updatePulses(sdt);
      updateHypeState(sdt);
      updateMomentumState(sdt);
      if(state.autoPlay && state.hype >= state.hypeMax && state.hypeActiveTimer<=0) activateHype(true);
      UI.money.textContent=state.money;
      UI.lives.textContent=state.lives;
      UI.wave.textContent=state.wave;
      UI.enemies.textContent=state.enemies.length+state.enemiesRemaining+(state.wavePlan?state.wavePlan.length:0);
      if(waveJustCleared && clearedWaveIndex!=null) recordAutoPlayWave(clearedWaveIndex);
      updateSelectedTowerInfo();
    }

    function drawBackground(){ if(assets.bgImg){ const iw=assets.bgImg.naturalWidth||assets.bgImg.width, ih=assets.bgImg.naturalHeight||assets.bgImg.height; const s=Math.max(W/iw,H/ih); const w=iw*s,h=ih*s; ctx.globalAlpha=0.45; ctx.drawImage(assets.bgImg,(W-w)/2,(H-h)/2,w,h); ctx.globalAlpha=1; } }
    function drawGrid(){ ctx.strokeStyle='rgba(27,34,68,0.65)'; ctx.lineWidth=1; for(let x=0;x<=W;x+=GRID){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } for(let y=0;y<=H;y+=GRID){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); } }
    function drawPath(){ ctx.strokeStyle='rgba(30,41,59,0.9)'; ctx.lineWidth=28; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(waypoints[0].x,waypoints[0].y); for(let i=1;i<waypoints.length;i++) ctx.lineTo(waypoints[i].x,waypoints[i].y); ctx.stroke(); ctx.fillStyle='#eab308'; ctx.fillRect(W-30, waypoints[waypoints.length-1].y-20, 24, 40); }
    function draw(){ ctx.clearRect(0,0,W,H); drawBackground(); drawGrid(); drawPath();
      for(const pulse of state.pulses){ const life=pulse.life||0.6; const alpha=Math.max(0, (pulse.ttl>0?pulse.ttl:0)/life); if(alpha<=0) continue; ctx.save(); ctx.globalAlpha=alpha*0.35; ctx.strokeStyle=pulse.color||'#c084fc'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(pulse.x, pulse.y, pulse.r||0, 0, Math.PI*2); ctx.stroke(); ctx.restore(); }
      for(const t of state.towers) t.draw(ctx);
      for(const e of state.enemies) e.draw(ctx);
      ctx.fillStyle='#e5e7eb';
      for(const b of state.bullets){ ctx.fillStyle=b.color||'#e5e7eb'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r||3.5,0,Math.PI*2); ctx.fill(); }
      for(const bolt of state.lightning){ if(!bolt.points||bolt.points.length<2) continue; const life=bolt.life||0.18; const alpha=Math.max(0, bolt.ttl/life); if(alpha<=0) continue; ctx.save(); ctx.globalAlpha=alpha; ctx.strokeStyle=bolt.color||'#facc15'; ctx.lineWidth=2.2; ctx.beginPath(); ctx.moveTo(bolt.points[0].x, bolt.points[0].y); for(let i=1;i<bolt.points.length;i++){ const p=bolt.points[i]; ctx.lineTo(p.x,p.y); } ctx.stroke(); ctx.restore(); }
      if(state.momentumActiveTimer>0){ ctx.save(); const flicker = 0.08 + 0.12*Math.sin(performance.now()/150); const alpha=Math.max(0.05, Math.min(0.28, flicker)); ctx.fillStyle=`rgba(251,113,133,${alpha})`; ctx.fillRect(0,0,W,H); ctx.restore(); }
      if(state.hypeActiveTimer>0){ ctx.save(); const pulse = 0.12 + 0.18*Math.sin(performance.now()/180); const alpha=Math.max(0.08, Math.min(0.3, pulse)); ctx.fillStyle=`rgba(56,189,248,${alpha})`; ctx.fillRect(0,0,W,H); ctx.restore(); }
      if(state.build && state.mouse){ const {gx,gy}=worldToGrid(state.mouse.x,state.mouse.y); const pos=gridToWorld(gx,gy); const valid=canPlaceAt(gx,gy); ctx.globalAlpha=0.5; ctx.fillStyle= valid? '#5b72ff':'#ef4444'; ctx.beginPath(); ctx.arc(pos.x,pos.y,18,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; ctx.strokeStyle='rgba(147,162,255,.22)'; ctx.beginPath(); ctx.arc(pos.x,pos.y,TOWER_TYPES[state.selectedTowerType]?.range||140,0,Math.PI*2); ctx.stroke(); }
      if(state.gameOver){ ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='bold 42px system-ui'; ctx.fillText('Game Over', W/2, H/2-10); ctx.font='16px system-ui'; ctx.fillText('Refresh the page to restart', W/2, H/2+22); } }
    function loop(ts){ const t=ts/1000; const dt=Math.min(0.033, state.lastTime? t-state.lastTime:0); state.lastTime=t; update(dt); draw(); requestAnimationFrame(loop); }

    function runTests(){
      const results=[];
      results.push({name:'UI defined', pass: !!UI && !!UI.speedBtn && !!UI.modeIndicator});
      const fakeEnemies=[{alive:true,pos:{x:5,y:0},getRadius:()=>12},{alive:true,pos:{x:9,y:0},getRadius:()=>12}];
      const _hits=segmentCircleAllHits(0,0,10,0,fakeEnemies,3);
      results.push({name:'segmentCircleAllHits order', pass:_hits.length>=2 && _hits[0].i===0 && _hits[1].i===1});
      const savedMoney=state.money; state.money=1e9; const t=new Tower(0,0,'basic'); const d0=t.damage, r0=t.rate, R0=t.range, p0=t.pierce; const ok=t.upgrade();
      results.push({name:'tower upgrade', pass: ok && t.damage>d0 && t.rate<=r0 && t.range>=R0});
      while(t.level%3!==0) t.upgrade();
      results.push({name:'pierce increments', pass: t.pierce>p0});
      state.money=savedMoney;
      const momentumSnapshot = { momentum: state.momentum, timer: state.momentumActiveTimer, chain: state.momentumChainGrace, combo: state.momentumCombo, last: state.momentumLastKillTime, money: state.money, kills: state.kills, earned: state.totalEarned, hype: state.hype, hypeTimer: state.hypeActiveTimer, hypePing: state.hypeReadyPinged, pulses: state.pulses.slice() };
      state.lastTime = 5;
      state.momentum = 0;
      state.momentumActiveTimer = 0;
      state.momentumChainGrace = 0;
      state.momentumCombo = 0;
      state.momentumLastKillTime = 0;
      const momentumEnemy = new Enemy('grunt'); momentumEnemy.hp = 1; applyDamage(momentumEnemy, 999, { dmg: 999 });
      const momentumGained = state.momentum > 0 && state.momentumCombo === 1;
      state.momentum = Math.max(0, state.momentumMax - 2);
      state.lastTime += 0.2;
      const momentumEnemy2 = new Enemy('grunt'); momentumEnemy2.hp = 1; applyDamage(momentumEnemy2, 999, { dmg: 999 });
      const frenzyTriggered = state.momentumActiveTimer > 0;
      state.momentumActiveTimer = 0;
      state.momentum = 60;
      state.momentumCombo = 4;
      shatterMomentum(2);
      const momentumPenalty = state.momentum < 60 && state.momentumCombo <= 2;
      state.momentum = momentumSnapshot.momentum;
      state.momentumActiveTimer = momentumSnapshot.timer;
      state.momentumChainGrace = momentumSnapshot.chain;
      state.momentumCombo = momentumSnapshot.combo;
      state.momentumLastKillTime = momentumSnapshot.last;
      state.money = momentumSnapshot.money;
      state.kills = momentumSnapshot.kills;
      state.totalEarned = momentumSnapshot.earned;
      state.hype = momentumSnapshot.hype;
      state.hypeActiveTimer = momentumSnapshot.hypeTimer;
      state.hypeReadyPinged = momentumSnapshot.hypePing;
      state.pulses.length = 0;
      Array.prototype.push.apply(state.pulses, momentumSnapshot.pulses);
      updateMomentumUI();
      results.push({name:'momentum gain on kill', pass: momentumGained});
      results.push({name:'momentum frenzy triggers', pass: frenzyTriggered});
      results.push({name:'momentum leak penalty', pass: momentumPenalty});
      const e=new Enemy('grunt'); const rFull=e.getRadius(); e.hp=e.maxHp*0.05; const rLow=e.getRadius();
      results.push({name:'enemy radius scales with hp', pass: rFull>rLow && Math.abs(rLow-12)<0.01});
      const plan=generateWavePlan(0); const total=plan.length; const expected=WAVES[0].reduce((s,g)=>s+g.count,0);
      results.push({name:'wave plan total count (w0 no boss)', pass: total>=expected});
      const plan2=generateWavePlan(1);
      results.push({name:'boss appears wave 2+', pass: plan2.some(p=>p.type==='boss')});
      const gOnPath = worldToGrid(waypoints[1].x, waypoints[1].y);
      results.push({name:'cannot place on path', pass: !canPlaceAt(gOnPath.gx, gOnPath.gy)});
      const old = state.speedMultiplier; state.speedMultiplier=9; const next = (state.speedMultiplier % 9) + 1; results.push({name:'speed cycles to 1 after 9', pass: next===1}); state.speedMultiplier=old;
      const slowEnemy = new Enemy('fast'); const baseSpd = slowEnemy.baseSpeed; slowEnemy.applySlow(0.5,1); slowEnemy.update(0.016);
      results.push({name:'slow effect reduces speed', pass: slowEnemy.speed < baseSpd});
      results.push({name:'boss leaks hurt', pass: BAL.bossLeakLives>1});
      results.push({name:'tower variety', pass: Object.keys(TOWER_TYPES).length>=4});
            const prevWaveState = state.wave; state.wave = 1; applyWaveEvent(); const eventApplied = !!state.activeEvent && !!state.eventModifiers; clearWaveEvent(); state.wave = prevWaveState; updateEventUI();
      const hypeSaved = { hype: state.hype, hypeMax: state.hypeMax, timer: state.hypeActiveTimer, ping: state.hypeReadyPinged }; state.hype = 0; state.hypeMax = 10; gainHype(12); const hypeReady = state.hype === state.hypeMax; activateHype(true); const hypeActive = state.hypeActiveTimer > 0; state.hype = hypeSaved.hype; state.hypeMax = hypeSaved.hypeMax; state.hypeActiveTimer = hypeSaved.timer; state.hypeReadyPinged = hypeSaved.ping; state.pulses.length = 0; updateHypeUI();
      const stormTestTower = new Tower(0,0,'storm'); const testEnemyA = new Enemy('grunt'); const testEnemyB = new Enemy('fast'); testEnemyA.pos={x:80,y:80}; testEnemyB.pos={x:140,y:80}; testEnemyA.alive=true; testEnemyB.alive=true; state.enemies=[testEnemyA,testEnemyB]; performChainLightning(stormTestTower, testEnemyA, {damageMult:1}); const chainWorked = testEnemyB.hp < testEnemyB.maxHp; state.enemies.length = 0;
      results.push({name:'wave event applied', pass: eventApplied});
      results.push({name:'hype activation works', pass: hypeReady && hypeActive});
      const crowdSaved = { request: state.crowdRequest, tracker: state.crowdTracker, streak: state.crowdStreak };
      const crowdWaveSaved = state.wave;
      const moneySaved = state.money;
      state.wave = 3;
      beginCrowdRequest();
      const crowdCreated = !!state.crowdRequest;
      let crowdProgressed = false;
      if(state.crowdRequest){
        const key = state.crowdRequest.key;
        if(key === 'flawless'){
          notifyCrowd('lifeLost', { amount: 1 });
          crowdProgressed = state.crowdRequest.status === 'failed';
        } else if(key === 'blueprint'){
          notifyCrowd('build', {});
          crowdProgressed = (state.crowdRequest.tracker?.builds || 0) > 0 || state.crowdRequest.status !== 'active';
        } else if(key === 'glowup'){
          state.money = 1e6;
          const tempTower = new Tower(0,0,'basic');
          state.towers.push(tempTower);
          tempTower.upgrade();
          crowdProgressed = (state.crowdRequest.tracker?.upgrades || 0) > 0 || state.crowdRequest.status !== 'active';
          state.towers.pop();
        } else if(key === 'hypeburst'){
          const saved = { hype: state.hype, max: state.hypeMax, timer: state.hypeActiveTimer, ping: state.hypeReadyPinged };
          state.hype = state.hypeMax;
          activateHype(true);
          crowdProgressed = state.crowdRequest.status === 'complete';
          state.hype = saved.hype;
          state.hypeMax = saved.max;
          state.hypeActiveTimer = saved.timer;
          state.hypeReadyPinged = saved.ping;
        } else {
          notifyCrowd('kill', { enemy: new Enemy('grunt') });
          crowdProgressed = (state.crowdRequest.tracker?.kills || 0) > 0 || state.crowdRequest.status !== 'active';
        }
      }
      state.money = moneySaved;
      state.crowdRequest = crowdSaved.request;
      state.crowdTracker = crowdSaved.tracker;
      state.crowdStreak = crowdSaved.streak || 0;
      state.wave = crowdWaveSaved;
      updateCrowdUI();
      results.push({name:'crowd request spawns', pass: crowdCreated});
      results.push({name:'crowd request tracks progress', pass: crowdCreated ? crowdProgressed : true});
      results.push({name:'storm chain damages secondary', pass: chainWorked});
const sim = simulateOnce(10, 300);
      results.push({name:'simulateOnce returns summary', pass: sim && sim.summary && Number.isFinite(sim.summary.wavesSurvived)});
      const allPass=results.every(r=>r.pass);
      if(allPass) console.log('[TD Tests] All tests passed:', results);
      else console.error('[TD Tests] Some tests failed:', results);
    }

    function simulateOnce(maxWaves, timeBudgetMs = 1500){
      const t0 = performance.now();
      maxWaves   = Math.max(1, Math.min(200, maxWaves|0));
      timeBudgetMs = Math.max(200, Math.min(4000, timeBudgetMs|0));

      state.money=120; state.lives=20; state.wave=0; state.enemies=[]; state.towers=[]; state.bullets=[]; state.wavePlan=[]; state.waveClock=0; state.kills=0; state.totalEarned=0; state.towersBuilt=0; state.gameOver=false; state.autoStart=true; state.autoPlay=true; state.speedMultiplier=6; state.build=false; state.selling=false; state.silenceAutoReport=true; state.autoReport=null; state.crowdRequest=null; state.crowdTracker=null; state.crowdStreak=0; state.momentum=0; state.momentumActiveTimer=0; state.momentumChainGrace=0; state.momentumCombo=0; state.momentumLastKillTime=0; aiCandidates=nearTurnTiles();
      const wavesLog=[]; startWave();
      let steps=0,lastWave=0; const MAX_STEPS = Math.min(150000, maxWaves*6000);
      try{
        while(!state.gameOver && state.wave < maxWaves){
          update(0.033);
          if(state.wave!==lastWave){ wavesLog.push({wave:state.wave,money:state.money,lives:state.lives,towers:state.towers.length,kills:state.kills}); lastWave=state.wave; }
          if(state.enemies.length===0 && state.enemiesRemaining===0 && !state.gameOver){ startWave(); }
          if(++steps>MAX_STEPS) break;
          if(performance.now()-t0 > timeBudgetMs) break;
        }
      } finally {
        const elapsed=Math.round(performance.now()-t0);
        const summary={ wavesSurvived: state.wave, livesEnd: state.lives, moneyEnd: state.money, kills: state.kills, towers: state.towers.length, towersBuilt: state.towersBuilt, totalEarned: state.totalEarned, ms: elapsed, steps };
        state.enemies.length=0; state.towers.length=0; state.bullets.length=0; state.wavePlan.length=0;
        resetInteractiveState();
        return {summary, wavesLog};
      }
    }

    function tuneTowards(target, result){
      const {wavesSurvived, moneyEnd} = result.summary;
      const err = wavesSurvived - target;

      if (err > 0) {
        const mag = Math.min(0.28, err/target);
        BAL.hpLinearSlope   *= 1 + mag;
        BAL.hpPeriodicStep  *= 1 + mag*0.65;
        BAL.countSlope      *= 1 + Math.min(0.20, mag*0.75);
        BAL.bossEvery        = Math.max(2, Math.round(BAL.bossEvery*0.88));
        BAL.bossLeakLives    = Math.max(2, Math.min(6, (BAL.bossLeakLives|0) + 1));
        BAL.rewardSlope      = Math.max(0.006, +(BAL.rewardSlope*0.92).toFixed(3));
        BAL.aiBaseDesired    = Math.max(3, (BAL.aiBaseDesired|0) - 1);
        BAL.desiredTowersCap = Math.max(30, Math.min(42, (BAL.desiredTowersCap|0)));
      } else if (err < 0) {
        const mag = Math.min(0.35, -err/target);
        BAL.hpLinearSlope   *= (1 - mag*0.8);
        BAL.hpPeriodicStep  *= (1 - mag*0.6);
        BAL.countSlope      *= (1 - mag*0.45);
        BAL.bossEvery        = Math.min(10, Math.round(BAL.bossEvery*1.18));
        BAL.bossLeakLives    = Math.max(1, Math.min(5, (BAL.bossLeakLives|0) - 1));
        BAL.rewardSlope      = Math.min(0.03, +(BAL.rewardSlope*1.10).toFixed(3));
        BAL.aiBaseDesired    = Math.min(6, (BAL.aiBaseDesired|0) + 1);
        BAL.desiredTowersCap = Math.min(45, Math.max(34, (BAL.desiredTowersCap|0)));
      }

      if (wavesSurvived < Math.max(8, Math.floor(target/3))) {
        BAL.bossEvery        = Math.min(12, BAL.bossEvery + 1);
        BAL.bossLeakLives    = Math.max(1, Math.min(4, BAL.bossLeakLives));
        BAL.aiBaseDesired    = Math.min(6, (BAL.aiBaseDesired|0) + 1);
        BAL.aiCooldown       = Math.max(0.22, (BAL.aiCooldown||0.35) - 0.03);
      }

      if (wavesSurvived >= target && moneyEnd > 100000) {
        BAL.clearBase    = Math.max(0, Math.round(BAL.clearBase*0.9));
        BAL.clearPer     = Math.max(1, Math.round(BAL.clearPer*0.9));
        BAL.rewardSlope  = Math.max(0.004, +(BAL.rewardSlope*0.9).toFixed(3));
      }

      BAL.hpLinearSlope  = +Math.min(1.2, Math.max(0.001, BAL.hpLinearSlope)).toFixed(6);
      BAL.hpPeriodicStep = +Math.min(2.0, Math.max(0.01,  BAL.hpPeriodicStep)).toFixed(6);
      BAL.countSlope     = +Math.min(0.6, Math.max(0.005, BAL.countSlope)).toFixed(6);
      BAL.bossEvery      = Math.max(2, Math.min(12, BAL.bossEvery|0));
      BAL.bossLeakLives  = Math.max(1, Math.min(6,  BAL.bossLeakLives|0));
      BAL.aiBaseDesired  = Math.max(2, Math.min(6,  BAL.aiBaseDesired|0));
      BAL.aiCooldown     = +Math.min(0.6, Math.max(0.2, BAL.aiCooldown||0.35)).toFixed(2);
      BAL.desiredTowersCap = Math.max(30, Math.min(45, BAL.desiredTowersCap|0));
    }

    function runAutoTuneIters(){
      const requested = UI.simIters.value|0;
      const iters = Math.min(30, Math.max(1, requested));
      const cap   = Math.min(160, Math.max(10, UI.simMax.value|0));
      const target= Math.max(5, UI.targetWave.value|0);
      const perIterBudget = iters > 10 ? 900 : 1500;

      const logs = [];
      for(let i=0;i<iters;i++){
        const r = simulateOnce(cap, perIterBudget);
        logs.push({iter:i+1, result:r});
        tuneTowards(target, r);
      }
      const finalRun = simulateOnce(cap, Math.max(perIterBudget, 1500));
      logs.push({iter:'final', result: finalRun});

      const header = requested>iters ? `(capped at ${iters} iters for stability)\n` : '';
      const display = header + logs.map(({iter, result})=>`#${iter} waves=${result.summary.wavesSurvived} lives=${result.summary.livesEnd} kills=${result.summary.kills} towers=${result.summary.towers} $end=${result.summary.moneyEnd} ms=${result.summary.ms} steps=${result.summary.steps}`).join('\n');
      UI.simOut.textContent = display + '\n\nNew BAL =>\n' + JSON.stringify(BAL, null, 2);
      dumpParams();
      return {logs, BAL: JSON.parse(JSON.stringify(BAL))};
    }

    UI.runAutoTune.addEventListener('click', () => { UI.runAutoTune.disabled = true; try { const res = runAutoTuneIters(); console.log('[Auto-Tune]', res); } finally { UI.runAutoTune.disabled = false; } });
    UI.resetBal.addEventListener('click', ()=>{ Object.assign(BAL, { hpLinearSlope:0.22, hpPeriodicEvery:10, hpPeriodicStep:0.70, countSlope:0.20, bossEvery:4, bossLeakLives:4, rewardSlope:0.02, clearBase:10, clearPer:4, armorPerWave:0.6, armorTank:10, armorBoss:20, desiredTowersCap:45, aiBaseDesired:3, aiCooldown:0.35 }); dumpParams(); });

    function init(){
      buildShop();
      resetInteractiveState();
      dumpParams();
      updateAutoReportPanel();
      requestAnimationFrame(loop);
      setTimeout(runTests,0);
    }
    init();
  </script>
</body>
</html>
